# 17.标准库特殊措施



## 17.2 biset类型

### 17.2.1 定义和初始化bitset

bitset类是一个类模板，当我们定义一个bitset时，需要声明它包含多少个二进制位:

```C++
bitset<32> bitvec(1U); // 32位;低位为1，其他位为0
```

大小必须是一个常量表达式。

我们通过位置来访问它们。二进制位的位置是从0开始编号的。因此，bitvec 包含编号从0到31的32个二进制位。

编号从0开始的二进制位被称为**低位**(low-order),
编号到31结束的二进制位被称为**高位**(high-order)。

![image-20210606214927549](Typora_img/image-20210606214927549.png)

**用unsigned值初始化bitset**

简单的说，不足的时候，高位补0，超过的时候，截断unsigned的高位

```C++
0xbeef的二进制  1011 1110 1110 1111

// bitvec1 比初始值小;初始值中的高位被丟弃
bitset<13> bitvecl (0xbeef); // 二进制位序列为1111011101111
// bitvec2比初始值大;它的高位被置为0
bitset<20> bitvec2 (0xbeef) ;// 二进制位序列为00001011111011101111
//在64位机器中，long long OULL是64个0比特，因此~0ULL是64个1
bitset<128> bitvec3(~0ULL); // 0~63 位为1; 63~127 位为0

```



**从一个string初始化bitset**

```C++
bitset<32> bitvec4 ("1100"); // 2、3两位为1,剩余两位为0

string str ("1111111000000011001101") ;
bitset<32> bitvec5(str, 5，4); // 从str[5]开始的四个二进制位，1100
bitset<32> bitvec6(str, str.size()-4); //使用最后四个字符

```

string的下标编号习惯与bitset恰好相反:string中下标最大的字符(最
右字符)用来初始化bitset中的低位(下标为0的二进制位)。

![image-20210606215219102](Typora_img/image-20210606215219102.png)

```C++
bitset<32> bitvec(1U) ;//32位;低位为1,剩余位为0
bool is_set = bitvec.any() ;// true，因为有1位置位
bool is_not_set= bitvec.none();// false,因为有1位置位了
bool all_set = bitvec.all () ;//false,因为只有1位置位
size_ t onBits = bitvec. count() ;//返回1
size_ t sZ = bitvec.size() ;//返回32，
bitvec.flip(); // 翻转bitvec中的所有位
bitvec.reset(); // 将所有位复位.
bitvec.set() ;//将所有位置位，
bitvec.flip(0); // 翻转第一位
bitvec.set(bitvec.size()-1); //置位最后一位
bitvec.set(0，0);//复位第一位
bitvec.reset(i);//复位第i位
bitvec.test(0);//返回false,因为第一位是复位的
//下标运算符对const属性进行了重载。const 版本的下标运算符在指定位置位时返回true，否则返回false。非const版本返回bitset定义的一个特殊类型，它允许我们操纵指定位的值:
bitvec[0] = 0;//将第一位复位
bitvec[31] = bitvec[0]; // 将最后一位设置为与第一位一样
bitvec[0].flip() ;//翻转第一位
~bitvec[0] ;//等价操作，也是翻转第一位
bool b = bitvec[0] ;//将bitvec[0]的值转换为bool类型

```



**提取bitset的值**

```C++
//to_ulong 和to_ullong 操作都返回一个值,保存了与bitset对象相同的位模式。
//只有当bitset的大小小于等于对应的大小(to_ulong 为unsigned long,to_ullong为unsigned long long)时，我们才能使用这两个操作:
unsigned long ulong = bitvec3.to_ulong() ;
cout << "ulong = " << ulong << endl;

```

**bitset的I0运算符**

```C++
//输出运算符打印一个bitset对象中的位模式:
bitset<16> bits;
cin >> bits; //从cin读取最多16个0或1
cout << "bits: ”<< bits << endl; // 打印刚刚读取的内容

```

**使用bitset**

```C++
//使用标准库类bitset完成等价的工作
bitset<30> quizB;//每个学生分配一位，所有位都被初始化为0
quizB.set (27) ;//指出第27个学生通过了测验
status = quizB[27] ;//检查第27个学生是否通过了测验
quizB. reset(27) ;//第27个学生未通过测验

```



## 17.3 正则表达式

正则表达式：一种描述字符的方式

![image-20210130141443511](./Typora_img/image-20210130141443511.png)

组件定义在头文件regex.h中

函数regex_ match和regex_ search 确定一个给定字 符序列与一个给定regex是否匹配

如果整个输入序列与表达式匹配，则regex_ match函数返回true;

如果输入序列中一个子串与表达式匹配，则regex_ search 函数返回true。 

![image-20210130141632059](./Typora_img/image-20210130141632059.png)

### 17.3.1 使用正则表达式

```C++
//查找不在字符c之后的字符串ei
string pattern("[^c]ei") ;
//我们需要包含pattern的整个单词
pattern = "[[:alpha:]]*" + pattern + "[[:alpha:]] *";
regex r (pattern) ;//构造一个用于查找模式的regex
smatch results;//定义一个对象保存搜索结果

//定义一个string保存与模式匹配和不匹配的文本
string test_ str = "receipt freind theif receive";
//用r在test str中查找与pattern匹配的子串
if (regex_search(test_ str, results, r)) // 如果有匹配子串
 //regex_search将会在test_str中查找与regex对象r匹配的单词，如果找到匹配子串，results 将会保存匹配位置的细节信息。
cout << results.str() << endl ;
//打印匹配的单词,结果为friend

```

正则表达式[ ^c ]表明我们希望匹配任意不是'c'的字符

[ ^c ]ei指出我们想要匹配这种字符后接ei的字符串。

默认情况下，regex使用的正则表达式语言是ECMAScript。

在ECMAScript中，模式[[: :alpha:]]匹配任意字母，符号+和*分别表示我们希望“一个或多个”或
“零个或多个”匹配。



**指定regex对象的选项**

![image-20210130142320863](./Typora_img/image-20210130142320863.png)

最后6个标志指出编写正则表达式所用的语言。对这6个标志，我们必须设置其中之一，且只能设置一个。默认情况下，ECMAScript标志被设置。

```C++
//例：用regex::icase标志查找具有特定扩展名的文件名
//一个或多个字母或数字字符后接一个' .'再接"cpp"或"cxx"或"cc"
regex r("[[ :alnum:]]+\\. (CPPIcxx|cc)$", regex: :icase) ;
smatch results;
string filename;
while (cin >> filename)
if (regex_ search (filename，results， r) )
cout << results.str() << endl; //打印匹配结果

此表达式将匹配这样的字符串: 一个或多个字母或数字后接一个句点再接三个文件扩展名
之一。

```

正则表达式语言通常也有特殊字符。例如，字符点(.)通常匹配任意字符。与C++一样，我们可以在字符之前放置一个反斜线来去掉其特殊含义。

为了表示与句点字符匹配的正则表达式，必须写成\\\\\. 

(第一个反斜线去掉C++语言中反斜线的特殊含义，即，正则表达式字符串为\，第二个反斜线则表示在正则表达式中去掉.的特殊含义)。



**指定或使用正则表达式时的错误**

**需要意识到的非常重要的一点是，一个正则表达式的语法是否正确是在运行时解析的。**

如果我们编写的正则表达式存在错误，则在运行时标准库会抛出一个类型为regex_error 的异常regex_error有一个what操作来描述发生了什么错误。

regex_error 还有一个名为 code的成员，用来返回某个错误类型对应的数值编码。	

```C++
//例如，我们可能在模式中意外遇到一个方括号:
try {
//错误:alnum漏掉了右括号，构造函数会抛出异常
regex r("[[:alnum: ]+\\. (cppIcxx|cc)$"，regex: :icase) ;
} catch (regex_ error e)
{ cout << e.what() << "\ncode:”<< e.code() << endl; }
//当这段程序在我们的系统上运行时，程序会生成:
regex_error (error_brack) :
The expression contained mi sma tched [ and ].
code: 4

```

![image-20210130142919370](./Typora_img/image-20210130142919370.png)

新的正则表达式可能是非常耗时的。特别是，如果你在一个循环中使用正则表达式，应该在循环外创建它，而不是在每步迭代时都编译它。



**正则表达式类和输入序列类型**

![image-20210130143022849](./Typora_img/image-20210130143022849.png)

```C++
regex r("[[ :alnum:]]+\\. (cppIcxx|cc)$", regex: :icase) ;
smatch results; //将匹配string输入序列，而不是char*
if (regex_ search ("myfile.cc"，results, r)) // 错误:输入为char*
cout << results.str() << endl ;
//这段代码会编译失败，因为match参数的类型与输入序列的类型不匹配。如果我们希望搜索一个字符数组，就必须使用cmatch对象: 
cmatch results; //将匹配字符数组输入序列
if (regex search ("myfile.cc",results，r) )
cout << results.str() << endl; // 打印当前匹配

```

### 17.3.2 匹配与Regex迭代器类型

我们可以使用sregex iterator来获得所有匹配

![image-20210130143224290](./Typora_img/image-20210130143224290.png)

![image-20210130143237046](./Typora_img/image-20210130143237046.png)

**使用sregex_iterator**

```C++
//查找前一个字符不是c的字符串ei
string pattern("[^c]ei") ;
//我们想要包含pattern的单词的全部内容
pattern = "[[:alpha:]]*" + pattern + "[[ :alpha:]] *";
regex r (pattern, regex: :icase); // 在进行匹配时将忽略大小写
//它将反复调用regex_search来寻找文件中的所有匹配
for (sregex_iterator it(file.begin(),file.end(),r),end_it;it != end_it; ++it)
cout << it->str() << endl; // 匹配的单词

```


当我们定义it时，sregex_iterator的构造函数调用regex_search 将it定位到file中第一个与r匹配的位置。而end_it 是一个空sregex_iterator, 起到尾后迭代器的作用。for语句中的递增运算通过regex_search 来“推进”迭代器。当我们解引用迭代器时，会得到一个表示当前匹配结果的smatch对象。即*it是一个smatch对象，我们调用它的str成员来打印匹配的单词。



**使用匹配数据**

smatch有两个名为prefix和suffix的成员的成员，分别返回表示输入序列中当前匹配之前和之后部分的ssub_ match 对象。一个ssub_ match对象有两个名为str和length的成员，分别返回匹配的string和该string的大小。

```C++
//循环头与之前一样
for (sregex_ iterator it(file.begin()， file.end(), r)，end_ it;
it != end it; ++it) {
auto pos = it->prefix().length() ;// 前缀的大小
pos=pos>40?pos一40:0;//我们想要最多40个字符
cout << it->prefix().str().substr (pos)//前缀的最后一部分
<< "\n\t\t>>> ”<< it->str() <<”<<<\n" //匹配的单词
<< it->suffix().str().substr(0，40) // 后缀的第一部分
<< endl;

```

![image-20210130143940607](./Typora_img/image-20210130143940607.png)

![image-20210130143952214](./Typora_img/image-20210130143952214.png)	

### 17.3.3 使用子表达式

括号()括起来的就是子表达式，其作用相当于分组，便于通过smatch的对应各个子表达式部分的输出，见下

```C++
// r有两个子表达式:第一个是点之前表示文件名的部分，第二个表示文件扩展名
regex r("([[:alnum:]]+)\\. (cpp|cxx|cc)$", regex: :icase) ;
//([[:alnum:]]+)， 匹配一个或多个字符的序列
//(cppIcxx|cc)， 匹配文件扩展名

```

```C++
if (regex_search (filename，results, r) )
cout << results.str(1) << endl; //打印第一个子表达式

```


子匹配是按位置来访问的。

第一个子匹配位置为0，表示整个模式对应的匹配，随后是每个子表达式对应的匹配。因此，本例模式中第一个子表达式，即表示文件名的子表达式，其位置为1，而文件扩展名对应的子表达式位置为2。
例如，如果文件名为
foo. cpp，则:results.str(0)将保存foo. cpp ;

results.str (1)将保存foo;

results.str (2)将保存cpp。



**ECMAScript正则表达式语言的一些特点**

- \\{d}表示单个数字而\\{d}{n}则表示一个n个数字的序列。(如，\\{d}{3}匹配
  三个数字的序列。)
- 在方括号中的字符集合表示匹配这些字符中任意一个。(如，[-. ]匹配一个短横，
  线或一个点或一个空格。注意，点在括号中没有特殊含义。)
- 后接'?'的组件是可选的。'?'应该与[-. ]?放在一起理解，表示可以匹配三个符号中的一个，但也可以没有这三个符号
- 括号是ECMAScript中的特殊字符，因此我们必须用\ (和 \\) 来表示括号是我们的模式的一部分 而不是特殊字符。



```C++
//整个正则表达式包含七个子表达式: ( ddd )分隔符ddd分隔符dddd
//子表达式1、3、4和6是可选的;2、5和7保存号码
"(\\()?(\\d{3}) (\\))?([-. ])?(\\d{3}) ([-. ]?) (\\d{4})";


1.(\\()?表示区号部分可选的左括号
2. (\\d{3}) 表示区号
3.(\\))?表示区号部分可选的右括号
4.([-.])?表示区号部分可选的分隔符
5. (\\d{3}) 表示号码的下三位数字
6.([-.])?表示可选的分隔符
7. (\\d{4})表示号码的最后四位数字

```

**使用子匹配操作**

我们的pattern 有七个子表达式。与往常一样，每个smatch 对象会包含八个ssub_match元素。位置[0]的元素表示整个匹配;元素[1.]..[7]表示每个对应的子表达式。

![image-20210130145542896](./Typora_img/image-20210130145542896.png)

### 17.3.4 使用regex_replace

regex_ replace。类似搜索函数，它接受一个输入字符序列和一个regex对象，不同的是，它还接受一个描述我们想要的输出形式的字符串。

![image-20210130145714990](./Typora_img/image-20210130145714990.png)

我们希望在替换字符串中使用第二个、第五个和第七个子表达式。而忽略第一个、第三个、第四个和第六个子表达式，我们用一个符号$后跟子表达式的索引号来表示--个特定的子表达式:

```C++
string fmt = "$2.$5.$7"; //将号码格式改为ddd.ddd.dddd
//只控制格式，不改变内容
string phone="(\\()?(\\d{3})(\\))?([-.])?(\\d{3})([-.]?)(\\d{4})"
regex r (phone); // 用来寻找模式的regex对象
string number = "(908) 555-1800";
cout << regex_replace (number, r, fmt) << endl;
//此程序的输出为:
908.555.1800

```

**用来控制匹配和格式的标志**

标准库还定义了用来在替换过程中控制匹配或格式的标志。这些标志可以传递给函数regex_ search 或regex match或是类smatch的format成员。

匹配和格式化标志的类型为match_flag_type.这些值都定义在名为regex_ constants 的命名空间中。regex_ constants 也是定义在命名空间std中的命名空间。

```C++
using std::regex_constants::format_no_copy;
using namespace std::regex_constants;
```

![image-20210130150205972](./Typora_img/image-20210130150205972.png)

```C++
//例：
//默认情况下，regex_replace 输出整个输入序列。未与正则表达式匹配的部分会原样输出;匹配的部分按格式字符串指定的格式输出。我们可以通过在regex_replace调用中指定format_no_copy 来改变这种默认行为:


string fmt2 = "$2.$5.$7 "; // 在最后一部分号码后放置空格作为分隔符
//通知regex_replace只拷贝它替换的文本
cout << regex_replace(s, r, fmt2， format_no_copy) << endl;

//给定相同的输入，此版本的程序生成
201.555.2368 862. 555.0123
973.555.0130
609.555.0132 201. 555.0175800. 555.0000

```



## 17.4 随机数

C函数使用rand来随机生成一个均匀分布的伪随机数，其范围为0到一个系统相关的最大值(32767)

C++通过**随机数引擎类**和**随机数分布类**来生成随机数

一个引擎类可以生成unsigned 随机数序列，

一个分布类使用一个引擎类生成指定类型的、在给定范围内的、服从特定概率分布的随机数。

C++程序不应该使用库函数rand,而应使用default_ random_engine类和恰当的分布类对象。

###  17.4.1 随机数引擎和分布

```C++
//调用随机数引擎对象来生成原始随机数
default_random_engine e; //生成随机无符号数
for (size_t i=0; i< 10; ++i)
{
cout << e() <" "; // e()“调用”对象来生成下一个随机数
}

//结果
16807 282475249 1622650073 984943658 1144108930 470211272...
//原始随机数，范围与机器有关
```

标准库定义了多个随机数引擎类，区别在于性能和随机性质质量不同，每个编译器会指定其中一个作为default_random_engine类型

![image-20210109144246756](./Typora_img/image-20210109144246756.png)

**分布类型和引擎**

使用分布类型对象获得指定范围内的数

```C++
//生成0到9之间(包含)均匀分布的随机数
uniform_int_distribution<unsigned> u(0,9); //此类型生成均匀分布的unsigned 值
default_random_engine e; //生成无符号随机整数
for(size_t i=0; i<10; ++i)
(
cout << u(e) <<" ";//分布对象使用引擎作为参数生成随机数，并映射到指定的范围
//传给u的是引擎对象本身e
//u(e());错误，将e生成的下一个值传给u
}
   
    //结果
    0 1 7 4 5 2 0 6 6 9
```

**随机数发生器=分布对象+引擎对象**

**比较随机数引擎和rand函数**

```c++
//调用default_random_engine对象的效果与使用rand函数相同
//通过min和max成员获得引擎类型的范围
cout << "min: " < e.min() < " max: " < e.max() << endl; 
//min: 1 max: 2147483646
//原始随机数在以上范围随机生成
```

**引擎生成一个数值序列**

每次调用程序都会生成相同的随机数

解决办法：将引擎和关联的分布对象定义为static的

```C++
//返回一个vector, 包含100个均匀分布的随机数
vector<unsigned> good_randVec ()
{
//由于我们希望引擎和分布对象保持状态，因此应该将它们定义为static的，从而每次调用都生成新的数
  static default_random_engine e;
  static uniform_int_distribution <unsigned> u(0,9);
   vector<unsigned> ret;
   for (size_t i= 0; i< 100; ++i)
      ret.push_back(u(e));
   return ret;
}
//由于e和u是static的，因此它们在函数调用之间会保持住状态。第一次调用会使用u(e)生成的序列中的前100个随机数，第二次调用会获得接下来100个
//如果没有加static修饰，则每次调用该函数产生的随机数都是相同的

//但是如果关闭程序再重新运行，产生的随机数和上一次运行第一次产生的随机数相同，通过设置随机数发生器种子解决该问题（见下）
```

**设置随机数发生器种子**

种子就是一个数值，引擎可以利用它从序列中一个新位置重新开始生成随机数。

为引擎设置种子有两种方式

- 在创建引擎对象时提供种子
- 或者调用引擎的seed成员

```C++
default_random_engine el; //使用默认种子
default_random_engine e2(2147483646); //使用给定的种子值

// e3和e4将生成相同的序列，因为它们使用了相同的种子
default_random_engine e3;//使用默认种子值
e3.seed(32767);//调用seed设置一个新种子值
default_random_engine e4(32767); //将种子值设置为32767
for (size_t i= 0; i!= 100; ++i) 
{
if (e1() == e2())
cout << "unseeded match at iteration: " << i << end1;
if (e3() != e4())
cout << "seeded differs at iteration: "<<i << endl;
}

```

**设置time种子**

time接受单个指针参数，返回从一个特定时刻到当前经过了多少秒，如果指针为空，则返回时间。

```C++
default_random_engine e1(time(0)); // 稍微随机些的种子
//由于time返回以秒计的时间，因此这种方式只适用于生成种子的间隔为秒级或更长的应用。
//如果程序作为一个自动过程的一部分反复运行，将time的返回值作为种子的方式就无效了;它可能多次使用的都是相同的种子。因为一秒内调用几百次，返回的时间都是相同的
```



### 17.4.2 其他随机数分布

标准库定义了不同随机数分布对象来生成不同类型或不同分布的随机数

 ![image-20210109150420071](./Typora_img/image-20210109150420071.png)

**生成随机实数**

```C++
//使用uniform_real_distribution类型的对象
default_random_engine e; // 生成无符号随机整数
//  生成0到1(包含)的均匀分布
uniform_real_distribution<double> u(0,1);
for (size_t i= 0; i< 10; ++i)
cout << u(e) <<" " ;

//结果
0.1315380.45865 0.218959 0.678865 0.934693 0.519416 ...

```

**使用分布的默认结果类型**

分布类型是模板，<>之间就是模板类型参数，表示要生成的随机数类型。生成浮点值的分布类型默认生成double值。生成整型值的分布默认生成int值。

```C++
//空<>表示我们希望使用默认结果类型
uniform_real_distribution<> u(0,1); //默认生成double值
```

**生成非均匀分布的随机数**

附录A.3 P781定义了20种分布类型

例如：通过normal_distribution生成服从正态分布的浮点随机数

```C++
default_random_engine e; //生成随机整数
normal_distribution<> n(4,1.5); //均值4，标准差1.5
vector<unsigned> vals(9); // 9个元素均为0
for(size_t i=0; i!=200; ++i)
{
 unsigned v = lround(n(e));  //lround将小数舍入到最接近的整数
    if (v<vals.size())  //如果结果在范围内
     ++vals[v]; //统计0-8每个数出现了多少次
}
for (size_t j =0; j!= vals.size(); ++j)
cout << j << ": " < string (vals[j],'*') << endl; 

```

结果

![image-20210109151500234](./Typora_img/image-20210109151500234.png)



**bernoulli_distribution类**

bernoulli_distribution是一个类，而不是模板，此分布返回一个bool值，返回true和false的概率都是0.5

```C++
default_random_engine e;  //e应保持状态，所以必须在循环外定义!
bernoulli_distribution b;// 默认是50/50的机会
for {int i=0; i<5; ++i)
{
bool first = b(e); //如果为true,则你先
cout << (first ? "We go first": "You get to go first")<< endl;
}
```

由于引擎返回相同的随机数序列，所以我们必须在循环外声明引擎对象。否则，每步循环都会创建一个新引擎，从而每步循环都会生成相同的值。类似的，分布对象也要保持状态，因此也应该在循环外定义。

```C++
bernoulli_distribution b(0.55); //true的概率变为0.55,false的概率变为0.45
```





# 18.用于大型程序的工具

## 18.1 异常处理

### 18.1.1 抛出异常

 当执行一个throw时，跟在throw后面的语句将不再被执行。相反，程序的控制权从throw转移到与之匹配的catch模块

**栈展开**

当抛出一个异常后，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的catch子句

- 首先匹配与当前try关联的catch子句
- 如果没找到，匹配外层try语句的catch子句
- 如果没找到，退出当前函数，在外层函数中继续寻找

以上过程为**栈展开**

当执行完catch子句后，找到与try块关联的最后一个catch子之后的点，并从这里继续执行。

如果没找到匹配的catch子句，程序将调用标准库函数terminate，然后程序将退出。

**一个异常如果没有被捕获，则它将终止当前的程序。**



**栈展开过程中对象被自动销毁**

如果在栈展开过程中退出了某个块，编译器将负责确保在这个块中创建的对象能被正确地销毁，哪怕对于类类型，其对象只构造了一部分，也要确保其正确地销毁。

**析构函数与异常**

在析构函数中抛出异常：函数中负责释放资源的代码可能被跳过

所以，如果析构函数需要执行某个可能抛出异常的操作，该异常要能够在析构函数内部被处理

在栈展开的过程中，运行类类型的局部对象的析构函数（局部变量被销毁）。因为这些析构函数是自动执行的，所以它们不应该抛出异常。

**异常对象**

抛出一个指向局部对象的指针是一种错误的行为，因为该块在catch语句之前就已经退出了，局部变量也被销毁，出于同样的原因，从函数中返回指向局部对象的指针也是错误的

当我们抛出一条表达式时，该表达式的静态编译时类型决定了异常对象的类型。

### 18.1.2 捕获异常

**查找匹配的处理代码**

 对于catch异常声明的匹配规则：绝大多数类型转换都是不被允许的，要求异常的类型与catch声明的类型是精确匹配的。

- 允许从非常量向常量的类型转换
- 允许从派生类向基类的类型转换
- 数组被转换成指向数组(元素)类型的指针，函数被转换成指向该函数类型的指针。

其他类型转换规则都不能使用

如果在多个catch语句的类型之间存在着继承关系，则我们应该把继承链最
底端的类(派生)放在前面，而将继承链最顶端的类(基类)放在后面。

因为匹配的时候是按顺序匹配的，如果派生类对象与前面的基类匹配了，那就无法实现派生类与派生类的精确匹配。

**重新抛出**

有时，一个单独的catch语句不能完整地处理某个异常，需要将异常传递给另外一个catch语句，重新抛出：throw不加表达式

```C++
throw;
```

空的throw语句只能出现在catch语句或catch语句直接或间接调用的函数之内。如果在处理代码之外的区域遇到了空throw语句，编译器将调用terminate.

**catch的形参是引用类型**

```C++
catch (my_error &e0bj) 
{//引用类型
e0bj.status = errCodes::severeErr;//修改了异常对象
throw;//异常对象的status成员是severeErr
}


catch (other_error e0bj) 
{//非引用类型
e0bj.status = errCodes::badErr; // 只修改了异常对象的局部副本
throw; //异常对象的status成员没有改变
}

```

**捕获所有异常的处理代码**

```C++
catch(...) //可以与任意类型的异常匹配
    
//catch(... )通常与重新抛出语句一起使用，其中catch执行当前局部能完成的工作，随后重新抛出异常:
void manip() 
{
try 
{
//这里的操作将引发并抛出一个异常
    catch(...)
    {
//处理异常的某些特殊操作
    throw;
    }
}

```

如果catch(...)与其他几个catch语句一起出现，则catch(...)必须在最后的位置。出现在捕获所有异常语句后面的catch语句将永远不会被匹配。



### 18.1.3 函数try语句块与构造函数

构造函数体内的catch语句无法处理构造函数初始值列表抛出的异常。

因为初始值列表不在函数内，还没有执行到catch语句，

解决办法：将构造函数写成函数try语句块

```C++
template <typename T>
B1ob<T>::Blob(std::initializer_list<T>il) try :
data (std::make_shared<std::vector<T>> (il)) 
{
/*空函数体*/
} catch(const std::bad_alloc &e) 
{ handle_out_of_memory(e);}
//注意try的位置
```

初始化构造函数参数的异常不能被捕获，这属于调用该函数时抛出的异常



### 18.1.4 noexcept异常说明

通过noexcept说明指定某个函数不会抛出异常

```C++
void recoup (int) noexcept;//不会抛出异常
void recoup(int) throw() ;// 等价的声明
//如果函数被设计为是throw()的，则也不会抛出异常
void alloc (int); //可能抛出异常.

```

- 在成员函数中，noexcept说明符需要跟在const及引用限定符之后，而在final、override或虚函数的=0之前。

- 在尾置返回类型之前
- 不能出现在typedef中

**违反异常说明**

编译器不在编译时检查noexcept说明

```C++
//以下情况，尽管有noexcept说明，函数还是会抛出异常

//尽管该函数明显违反了异常说明，但它仍然可以顺利编译通过
void f() noexcept//承诺不会抛出异常
{
    throw exception();//违反了异常说明
}
//此时程序会调用terminate函数，确保不在运行时出现异常
```

noexcept可以用在两种情况

- 一是我们确认函数不会抛出异常
- 二是我们根本不知道该如何处理异常。

**异常说明的实参**

noexcept接受一个bool型的可选实参，如果是true不抛出异常，如果是false，函数可能抛出异常

```C++
void recoup(int) noexcept (true) ;// recoup不会抛出异常
void alloc(int) noexcept (false) ;// alloc可能抛出异常
```



**noexcept运算符**

noexcept用于检查表达式是否会抛出异常，返回一个bool值

```C++
//因为我们声明recoup时使用了noexcept 说明符，所以下面的表达式的返回值为true:
noexcept (recoup(i));
noexcept (e);//当e调用的所有函数都做了不抛出异常说明且e本身不含有throw语句时，则true;否则noexcept (e)返回false。

void f() noexcept (noexcept(g())); // f和g的异常说明一致.
```



**异常说明与指针、虚函数和拷贝控制**

函数指针：

函数指针及该指针所指的函数必须具有一致的异常说明。

- 如果我们为某个指针做了不抛出异常的声明，则该指针将只能指向不抛出异常的函数。
- 如果我们显式或隐式地说明了指针可能抛出异常，则该指针可以指向任何函数，即使是承诺了不抛出异常的函数也可以。

```C++
// recoup和pf1都承诺不会抛出异常
void (*pf1) (int) noexcept = recoup;
//正确: recoup不会抛出异常，pf2可能抛出异常，二者之间互不干扰
void (*pf2) (int) = recoup;

pf1 = alloc;//错误: alloc可能抛出异常，但是pf1已经说明了它不会抛出异常
pf2 = alloc;//正确: pf2和alloc都可能抛出异常

```

- 如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚函数也必须做出同样的承诺;
- 如果基类的虚函数允许抛出异常，则派生类的对应函数既可以允许抛出异常，也可以不允许抛出异常

```C++
class Base 
{
public:
virtual double f1 (double) noexcept; // 不会抛出异常
virtual int f2 () noexcept (false) ; //可能抛出异常.
virtual void f3() ; //可能抛出异常
}; 

class Derived : public Base {
public:
double f1 (double) ; //错误: Base::f1承诺不会抛出异常
int f2() noexcept (false) ; //正确:与Base::f2的异常说明一致
void f3() noexcept;//正确: 

```

**合成拷贝控制成员**

如果对所有成员和基类的所有操作都承诺了不会抛出异常，则合成的成员是noexcept 的。

如果合成成员调用的任意一个函数可能抛出异常，则合成的成员是noexcept (false)



### 18.1.5 异常类层次

![image-20210107160403093](./Typora_img/image-20210107160403093.png)

层次越低，表示的异常情况越特殊，

exception 表示的含义是某处出错了，至于错误的细节则未作描述。

第二层将exception划分为两个大的类别:运行时错误和逻辑错误。

运行时错误表示的是只有在程序运行时才能检测到的错误;

而逻辑错误一般指的是我们可以在程序代码中发现的错误。



## 18.2 命名空间

命名空间是一个作用域，用于避免名字冲突

### 18.2.1 命名空间定义

```C++
namespace cplusplus_primer
{
class Sales_ data
    ...
    
}//命名空间结束后无须分号
//命名空间可以嵌套，但是不能定义在函数或类内部
```

**每个命名空间都是一个作用域**

不同命名空间内可以有相同名字的成员

定义在某个命名空间中的名字可以被该命名空间内的其他成员直接访问，也可以被这些成员内嵌作用域中的任何单位访问。位于该命名空间之外的代码则必须明确指出所用的名字属于哪个命名空间:

```C++
cplusp1us_primer::Query q =cplusplus_primer::Query("he1llo") ;
```

**命名空间可以是不连续的**

命名空间可以定义在几个不同的部分，不同部分的成员组合在一起是这个命名空间的定义

```C++
// --Sales. data.h文件中--
#include <string>
namespace cplusplus_primer 
{
class Sales_data { /* ...*/};//类的定义
...

}
// ---Sales_data.cpp ---

#include "Sales_data.h"
namespace cplusplus_primer.
{
//Sales.data成员的实现
}


//使用
//main.cpp
// Sales_ data.h头文件的名字位于命名空间cplusplus_primer中
#include "Sales_data.h"
int main()
{
using cplusplus_primer::Sales_data;
Sales_data trans1, trans2;
// ..
return 0;
}

```

**定义命名空间成员**

命名空间的成员可以在作用域内定义也可以在作用域外定义

```C++
//命名空间之外定义的成员必须使用含有前缀的名字
cplusplus_primer::Sales.data;//声明，因为后面会用到这个名字
cplusplus_primer::operator+(const Sales_data& 1hs,const Sales_datas rhs)
{
Sales_data ret (1hs);
}
//作用域外定义类似于类
```

在作用域外定义命名空间的成员要求，必须在命名空间的外层作用域，而不能在一个不相关的作用域内

 

**模板特例化**

模板特例化必须声明(也可以定义)在原始模板所属的命名空间中

```C++
//我们必须将模板特例化声明成std的成员
namespace std 
{
template <> struct hash<Sales_data>;
)//在std中添加了模板特例化的声明后，就可以在命名空间std的外部定义它了
    
template <> struct std::hash<Sales_data> 
size_t operator() (const Sales_data& s) const
{ 
...
};
```

**全局命名空间**

全局命名空间以隐式的方式声明，它没有名字

```C++
::member_name;//全局命名空间中的一个成员
```



**嵌套的命名空间**

```C++
namespace cplusplus_primer. 
{

    namespace QueryLib 
     {
        class Query { /* ...*/ };
     }

     namespace Bookstore 
     {
         ...
     }
}

//内层命名空间声明的名字将隐藏外层命名空间中同名成员
//如果要访问外层命名空间中的成员，需要加作用域限定符
cplusplus_primer::QueryLib::Query
```



**内联命名空间**

```C++
inline namespace FifthEd //显示内联
{

}

namespace FifthEd//隐式内联
{

}
//内联命名空间中的名字可以被外层命名空间直接使用
//关键字inline必须出现在命名空间第一次定义的地方，后续再打开命名空间的时候可以写inline,也可以不写。

```

**未命名的命名空间**

```C++
namesapce //未命名的命名空间
{
    
}
```

- 未命名的命名空间中定义的变量拥有静态生命周期(类似于静态变量)：它们在第一次使用前创建，并且直到程序结束才销毁。
- 未命名的命名空间可以在给定的文件内不连续，但是不能跨越多个文件。
- 如果两个文件都含有未命名的命名空间，则这两个空间互相无关。在这两个未命名的命名空间中可以定义相同的名字，并且这些定义表示的是不同实体。
- **如果一个头文件定义了未命名的命名空间，则该命名空间中定义的名字将在每个包含了该头文件的文件中对应不同实体。**
- 定义在未命名的命名空间中的名字可以直接使用，不需要作用域运算符
- 未命名的命名空间中定义的名字的作用域与该命名空间所在的作用域相同。

```C++
//未命名的命名空间中定义的名字的作用域与该命名空间所在的作用域相同。
//如果在最外层，需要与全局变量的名字有所区别

int i;// i的全局声明
namespace 
{
int i;//二义性: i的定义既出现在全局作用城中，又出现在未嵌套的未命名的命名空间中
}

namespace local 
{
     namespace 
     {
       int i;//正确:定义在嵌套的未命名的命名空间中的i与全局作用城中的i不同
     }
}
local::i = 42;

```

### 18.2.2 使用命名空间成员

**命名空间的别名**

```C++
namespace primer = cplusplus_primer;
//primer是命名空间cplusplus_primer的别名

//命名空间的别名也可以指向一个嵌套的命名空间:
namespace Q1ib = cplusplus_primer::QueryLib;

```

不能在命名空间还没有定义前就声明别名

一个命名空间可以有好几个同义词或别名，所有别名都与命名空间原来的名字等价。



**using声明**

```C++
using cplusplus_primer::Sales_data;
```

**using指示**

```C++
using namespace clpuscplus_primer;
//命名空间中的所有名字可见
```

**using指示与作用域**

using 声明只是令名字在该语句所在的局部作用域内有效

using指示一般被看作是出现在最近的外层作用域中

```C++
//A和函数f()都在全局作用域中
namespace A 
{
int i，j;
}

void f()
{
 using namespace A; //把A中的名字注入到全局作用域中
 cout<i*j<endl; //使用命名空间A中的主和j
}
```

```C++
namespace blip 
{
int i=16,j=15,k=23; //其他声明
}
int j=0; //正确: blip的j隐藏在命名空间中

void manip()
{
using namespace blip; // using指示，blip中的名字被“添加”到全局作用域中
 // 如果使用了j，则将在::j和blip::j之间产生冲突,因为两者的作用域相同
++i; //将blip::i设定为17
++j; //二义性错误:是全局的j还是blip::j?
++::j; //正确:将全局的j设定为1
++blip::j; //正确:将blip::j设定为16
int k=97; //当前局部的k隐藏了blip::k
++k; ///将当前局部的k设定为98
}
```

**头文件与using声明或指示**

using指示尽量用在本命名空间的实现文件中(.cpp)

**头文件如果在其顶层作用域中含有using指示或using声明,则会将名字注入到所有包含了该头文件的文件中。**

### 18.2.3 类、命名空间与作用域

```C++
//名字查找
namespace A 
{
   int i;
   namespace B 
   {
   int i; //在B中隐藏了A::i
   int j;
   int f1()
   {
     int j; //j是f1的局部变量，隐藏了A::B::j
   }
   return i; //返回B::i
} //命名空间B结束，此后B中定义的名字不再可见

int f2() 
{
  return j; //错误: j没有被定义
}
int j=i;  //用A::i进行初始化

```

查找的顺序

```C++
A::C1::f3;//先查找f3的作用域，再查找外层类C1的作用域，再查找命名空间A的作用域
```

**实参相关的查找与类类型形参**

```C++
std::string s;
std::cin >> s;

//上面语句等价于：
operator>> (std::cin，s);

```

operator>>函数定义在标准库string中，string又定义在命名空间std中。但是我们不用std::限定符和using声明就可以调用operator>>，为什么?

**当我们给函数传递一个类类型的对象时，除了在常规的作用域查找外还会查找实参类所属的命名空间。**

当编译器发现对operator>>的调用时，

- 首先在当前作用域中寻找合适的函数，
- 接着查找输出语句的外层作用域。
- 随后，因为>>表达式的形参是类类型的，所以编译器还会查找cin和s的类所属的命名空间。
- 也就是说，编译器会查找定义了istream和string的命名空间std。当在std中查找时，编译器找到了string的输出运算符函数。

如果没有以上规则，则需要以下调用方式

```C++
std::operator>>(std::cin, s);//正确:显式地使用std::>>
```

**友元声明与实参相关的查找**

如果一个函数被声明成某个类的友元函数，而他之前没有被声明过，则我们认为他是最近的外层命名空间的成员

```C++
namespace A 
{
   class C 
   {
     //两个友元，在友元声明之外没有其他的声明
     //这些函数隐式地成为命名空间A的成员
     friend void f2(); //除非另有声明，否则不会被找到
     friend void f1(const C&); //根据实参相关的查找规则可以被找到
    }
}
```

### 18.2.4 重载与命名空间

名字查找在实参所属命名空间中查找时，该命名空间的同名函数也被添加到候选集

```c++
namespace NS 
{
class Quote { /* ...*/ };
void display (const Quote&) { /* ...*/ }
}

// Bulk_item的基类声明在命名空间NS中
class Bulk_item : public NS::Quote { /* ...*/ };

int main() 
{
Bulk_item book1;
display (book1);
return 0;
}

//根据实参查找规则，编译器遇到display时，会在Bulk_item及其基类Quote所属的命名空间中查找。命名空间NS中声明的函数display (const Quotes) 也将被添加到候选函数集当中。
```

**重载与using声明**

```C++
//using声明函数不能指定形参
using NS::print (int); //错误:不能指定形参列表
using NS::print; //正确: using声明只声明一个名字

```

- using声明引入的函数与声明语句所属作用域中的其他同名函数构成重载
- 如果using声明出现在局部作用域中，则引入的名字将隐藏外层作用域的相关声明。
- 如果using声明引入的函数，与该声明语句所在作用域有函数同名且形参相同的函数，则using声明是错误的//相当于重载失败



**重载与using指示**

using指示将命名空间的成员提升到外层作用域中，此时可能会将命名空间的函数与外层作用域中的同名函数形成重载

比如说我们我们在.cpp文件中using namespace std；则编译器会把std空间的内容展开到当前作用域。

与using声明不同的是，对于using指示来说，**命名空间中的函数如果与外层作用域中的函数名相同且形参列表也相同，不会产生错误**，此时，只要我们指明调用的是命名空间中的函数版本还是外层作用域的版本即可。

如果是using声明，声明的函数与已有函数名相同，形参列表也相同，则错误

**跨越多个using指示的重载**

```C++
namespace AW 
{
int print(int);
}

namespace Primer 
{
double print (double);
}
// using 指示从不同的命名空间中创建了一个重载函数集合
using namespace AW;  //命名空间中的成员作用域被提到这一层
using namespace Primer;
long double print (1ong double);
int main() 
{
    //函数候选集有3个
print(1);//调用Aw::print (int)
print(3.1);//调用Primer::print (double)
return 0;
}
```



## 18.3 多重继承与虚继承

```C++
class Panda : public Bear, public Endangered { /* ..*/. };
//派生类能够继承的基类个数没有限制，但同一个基类只能出现一次
```

### 18.3.1 多重继承

**多重继承的派生类从每个基类中的继承状态**

派生类的对象包含有每个基类的子对象

![image-20210107212639544](./Typora_img/image-20210107212639544.png)

**派生类构造函数初始化所有基类**

```C++
//显式地初始化所有基类
Panda::Panda(std::string name, bool onExhibit): Bear (name, onExhibit, "Panda"),Endangered (Endangered::critical) { }

//隐式地使用Bear的默认构造函数初始化Bear子对象
 Panda::Panda (): Endangered (Endangered::critical) { }
```

基类的构造顺序与派生列表中基类的出现顺序保持一致， 而与派生类构造函数初始值列表中基类的顺序无关。

**构造顺序**

ZooAnimal 是整个继承体系的最终基类，ZooAnimal是Bear的直接基类，Bear 是Panda 的直接基类。即：Panda:(Bear,Endangered):ZooAnimal

当实例化一个Panda对象时

- 首先初始化ZooAnimal。
- 接下来初始化Panda的第一个直接基类Bear
- 然后初始化Panda的第二个直接基类Endangered。
- 最后初始化Panda。

**继承的构造函数与多重继承**

允许派生类从它的一个或几个基类中继承构造函数，但是如果从多个基类中继承了相同的构造函数。则程序将产生错误:

```C++
struct Base1 
{
Base1() = default;
Base1 (const std::string&);
Base1 (std::shared_ptr<int>);
};
struct Base2
{
Base2() = default;
Base2 (const std::string&) ;
Base2 (int);
};

//错误: D1试图从两个基类中都继承D1::D1 (const string&)
struct D1: public Base1, public Base2 
{
using Basel: :Basel;//从Basel继承构造函数
using Base2: :Base2;//从Base2继承构造函数
};

//解决办法：为继承来重复的构造函数定义自己的版本
struct D2: public Basel, public Base2 
{
using Basel::Basel; //从Basel继承构造函数
using Base2::Base2; //从Base2继承构造函数

 // D2必须自定义一个接受string的构造函数
D2 (const string &s): Basel(s),Base2 (s) { }
D2() = default; //一旦D2定义了它自己的构造函数，则必须出现
};

```

**析构函数与多重继承**

析构函数的执行顺序与构造函数相反，Panda对象的析构顺序

~ Panda

~Endangered 

~Bear 

~ZooAnimal.

**多重继承的派生类的拷贝与移动操作**

如果使用的是合成版本的拷贝、移动和赋值函数，每个基类分别使用自己的对应成员隐式地完成构造、赋值和销毁工作，其顺序与构造函数的调用顺序一致

### 18.3.2 类型转换与多个基类

将派生类对象传给基类指针或引用的形参

```C++
//接受Panda的基类引用的一系列操作
void print (const Bear&);
void highlight (const Endangered&);
ostreame operator<< (ostreama, const ZooAnimalG);
Panda ying_yang ("ying_yang");
print (ying_yang);//把一个Panda对象传递给一个Bear的引用
highlight(ying_yang);//把一个Panda对象传递给一个Endangered的引用
cout<<ying_yang<<endl;//把一个Panda对象传递给一个ZooAnimal的引用

```

```C++
//编译器不会在派生类向基类的几种转换中进行比较和选择，因为在它看来转换到任意一种基类都一样好。
void print (const Bear&);
void print (const Endangered&);

Panda ying_yang ("ying_yang");
print (ying_yang);//二义性错误
```

  **基于指针类型或引用类型的查找**

对象、指针和引用的静态类型决定了我们能够使用哪些成员

Panda (派生类)

Endangered    Bear （直接基类） 

ZooAnimal （基类）

一个ZooAnimal指针，则只有定义在ZooAnimal中的操作是可以使用。Panda 接口中的Bear、Panda 和Endangered特有的部分都不可见。

类似的，一个Bear类型的指针或引用只能访问Bear及ZooAnimal的成员，一个Endangered的指针或引用只能访问Endangered 的成员。

![image-20210108084135323](./Typora_img/image-20210108084135323.png)

```C++
Bear *pb = new Panda ("ying_yang");//基类指针指向派生类
pb->print();//正确: Panda::print() //print是虚函数，动态解析
pb->cuddle();//错误:不属于Bear的接口
pb->highlight();//错误:不属于Bear的接口
delete pb;//正确: Panda::~Panda ()

//通过Endangered的指针或引用访问一个Panda 对象时，Panda 接口中Panda特有的部分以及属于Bear的部分都是不可见的:
Endangered *pe = new Panda ("ying_ yang");
pe->print();//正确: Panda::print() 动态解析
pe->toes();//错误:不属于Endangered的接口
pe->cuddle();//错误:不属于Endangered的接口
pe->highlight();//正确: Panda::highlight() 动态解析
delete pe;//正确: Panda::~Panda ()
```



### 18.3.3 多重继承下的类作用域

如果我们通过Panda的对象、指针或引用使用了某个名字，则程
序会并行地在Endangered和Bear/ZooAnimal这两棵子树中查找该名字

多个直接基类的查找等级是相同的


当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况。

```C++
//如果ZooAnimal和Endangered都定义了名为max_weight的成员，并且Panda没有定义该成员，则下面的调用是错误的:
double d = ying_yang.max_weight(); 


//Panda在派生的过程中拥有了两个名为max_weight 的成员，这是完全合法的。派生仅是产生了潜在的二义性，只要Panda对象不调用max_weight 函数就能避免二义性错

//正确调用方式
ZooAnimal::max_weight 或者 Endangered::max_weight


//要想避免潜在的二义性，最好的办法是在派生类中为该函数定义一个新版本。例如，我们可以为Panda定义一个 max_weight函数从而解决二义性问题:
double Panda::max_weight() const
{
return std::max (ZooAnimal::max_weight(),Endangered::max_weight());
}

```



### 18.3.4 虚继承



istream和ostream 继承于 base_ios，

iostream继承于istream和ostream

那么在继承时，iostream可能会存在两份base_ios的拷贝

那么iostream将包含base_ios的多个重复子对象

解决该问题的办法就是**虚继承**

虚继约定共享基类，共享的基类子对象为**虚基类**

因此，在多重继承中，派生类只包含唯一一个共享的虚基类子对象

![image-20210108091952161](./Typora_img/image-20210108091952161.png)

**使用虚基类**

```C++
//通过virtual关键字我们将ZooAnimal定义为Raccoon和Bear的虚基类。
class Raccoon : public virtual ZooAnimal { };
class Bear : virtual public ZooAnimal {};
//virtual与public的顺序随意


//如果某个类指定了虚基类，则该类的派生仍按常规方式进行:
class Panda : public Bear,public Raccoon, public Endangered
{
};
//Panda通过Raccoon和Bear继承了ZooAnimal, 因为Raccoon和Bear继承ZooAnimal的方式都是虚继承，所以Raccoon 和Bear的派生类Panda中共享一个ZooAimal基类部分。

```

**虚基类成员的可见性**

假定类B定义了一个名为x的成员，D1和D2都是从B虚继承得到的，D继承了D1和D2，则在D的作用域中，x通过D的两个基类都是可见的。如果我们通过D的对象使用x，有三种可能性:

- 如果在D1和D2中都没有x的定义，则x将被解析为B的成员，此时不存在二义性，一个D的对象只含有x的一个实例。
- 如果x是B的成员，同时是D1和D2中某一个的成员，则同样没有二义性**，派生类的x比共享虚基类B的x优先级更高。**
- 如果在D1和D2中都有x的定义，则直接访问x将产生二义性问题。
- 与非虚的多重继承体系一样， **解决这种二义性问题最好的方法是在派生类中为成员自定义新的实例。**

### 18.3.5 构造函数与虚继承

只要我们能创建虚基类的派生类对象，该派生类的构造函数就必须初始化它的虚基类。

```C++
Panda:(Bear,Raccoon):ZooAnimal
Panda:Endangered

//当创建一个 Bear(或Raccoon)的对象时，它已经位于派生的最低层，因此Bear (或Raccoon)的构造函数将直接初始化其ZooAnimal基类部分:
Bear::Bear (std::string name, bool onExhibit)
:ZooAnimal (name, onExhibit, "Bear") { }

Raccoon::Raccoon(std::string name, bool onExhibit)
: ZooAnimal (name, onExhibit,"Raccoon") { }

//创建一个Panda 对象时，Panda 位于派生的最低层并由它负责初始化共享的ZooAnimal基类部分。即使ZooAnimal不是Panda的直接基类，Panda 的构造函数也可以初始化ZooAnimal:

Panda :: Panda (std::string name, bool onExhibit)
:ZooAnimal (name,onExhibit, "Panda")，
Bear (name，onExhibit)，
Raccoon (name, onExhibit)，
Endangered (Endangered: :critical)，
{ }

```

**虚继承的对象的构造方式**

首先使用提供给最低层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的次序依次对直接基类进行初始化。

例如，当我们创建一个Panda对象时:

- 首先使用Panda的构造函数初始值列表中提供的初始值构造虚基类ZooAnimal部分。
- 接下来构造Bear部分。
- 然后构造Raccoon部分
- .然后构造第三个直接基类Endangered。
- 最后构造Panda部分。

如果Panda没有显式地初始化ZooAnimal基类，则ZooAnimal的默认构造函数将被调用。



//感觉构造方式和不是虚继承没啥区别

**构造函数与析构函数的次序**

```C++
class Character { };
class BookCharacter : public Character { };
class ToyAnimal {  };
class TeddyBear : public BookCharacter,public Bear, public virtual ToyAnimal  { };

//编译器按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类。如果有，则先构造虚基类，然后按照声明的顺序逐一构造其他非虚基类。

//当创建TeddyBear对象时，以上继承关系按照以下顺序调用构造函数
Zo0Animal();// Bear的虚基类
ToyAnimal();//直接虚基类
Character();//第一个非虚基类的间接基类
BookCharacter();//第一个直接非虚基类
Bear();//第二个直接非虚基类
TeddyBear();//最低层的派生类

//合成的拷贝和移动构造函数的调用顺序相同，析构函数的调用顺序正好相反
```



# 19.特殊工具与技术

## 19.1 控制内存分配                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

### 19.1.1 重载new和delete

new时的第一步会调用名为operator new的标准库函数，**以获取内存空间**

delete的最后一步会调用名为operator delete 的标准库函数，**以释放内存空间**

如果希望自己控制内存分配的过程，需要定义自己的全局的operator new函数和operator delete函数

如果被分配的对象是类类型，则编译器首先在类及其基类的作用域中查找



**operator new接口和operator delete接口**

```C++
//标准库定义了operator new和operator delete函数的8个重载版本
//这些版本可能抛出异常
void *operator new(size_t); //分配一个对象
void *operator new[] (size_t); //分配一个数组
//以上两个，返回类型必须是void*

void *operator delete (void*) noexcept;//释放一个对象
void *operator delete[] (void*) noexcept;//释放一个数组   

//这些版本承诺不会抛出异常，参见12.1.2节(第409页)
void *operator new(size_t，nothrow_t&) noexcept;
void *operator new[](size_t，nothrow_t&) noexcept;
void *operator delete (void*, nothrow_t&) noexcept; 
void *operator delete[] (void*, nothrow_t&) noexcept;

//我们可以重新定义上面中任意一个
//第一个形参必须是size_t且不能有默认实参，接存储指定类型对象所需的字节数;

void *operator new(size_t，void*);//不允许重新定义这个版本

```



**malloc函数与free函数**

malloc函数接受一个表示待分配字节数的size_t, 返回指向分配空间的指针或者返回0以表示分配失败。

free 函数接受一个 void*,它是malloc返回的指针的副本，free将相关内存返回给系统。调用free(0)没有任何意义。



**一个重载new和delete的实例**

```C++
void *operator new(size_t size) 
{
if (void *mem = malloc(size))
     return mem; 
else
      throw bad_ alloc();
}
void operator delete (void *mem) noexcept
{ 
    free(mem); 
} 

```



### 19.1.2 定位new表达式

当我们需要在一个特定的、预先分配的内存地址上构造对象时，使用定位new表达式

```C++
new (place_address) type
new (place_address) type (initializers)
new (place_address) type [size]
new (place_adresss) type [size] { braced initializer list}
//其中place_ address 必须是一个指针，同时在initializer中提供一个(可能为空的)以逗号分隔的初始值列表，该初始值列表将用于构造新分配的对象。

```

**显式的析构函数调用**

```C++
string *sP = new string("a value"); //分配并初始化一个string对象
sp->~string();
//析构函数只会销毁对象，不会释放内存
```



## 19.2 运行时类型识别

- typeid运算符，用于返回表达式的类型
- dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。

当我们将这两个运算符用于某种类型的指针或引用，并且该类型含有虚函数时，运算符将使用指针或引用所绑定对象的动态类型

### 19.2.1 dynamic_cast运算符

```C++
//type必须是一个类类型，且该类型应该含有虚函数
dynamic_cast<type *>(e) //e必须是一个有效指针
dynamic_cast<type &>(e) //e必须是一个左值
dynamic_cast<type &&>(e) //e不能是左值

```

e的类型必须符合以下三个条件中的任意一个: 

- e的类型是目标type的公有派生类：派生类指针或引用转向基类指针或引用，
- e的类型是目标type的公有基类：基类指针或引用转向派生类指针或引用，这是不可以的
- e的类型就是目标type的类型。

如果符合，则类型转换可以成功。否则，转换失败，返回0。如果转换目标是引用类型并且失败了，则dynamci_cast运算符抛出一个bad_cast异常

**指针类型的dynamic_cast**

```C++
//一个示例，Derived是Base的派生类(public)
if (Derived *dp = dynamic_cast<Derived*> (bp))
//在条件部分执行dynamic_cast 操作可以确保类型转换和结果检查在同一条表达式中完成，因为转换失败结果为0，跳到else
{
   //dp指向Derived对象
} 
else //转换失败，结果为0 
{ 
    //bp指向Base对象
}

```

我们可以对一个空指针执行dynamic_cast, 结果是所需类型的空指针。

**引用类型的dynamic_cast**

引用类型的dynamic_cast转换失败，抛出一个std::bad_cast的异常

指针类型的dynamic_cast转换失败则其结果为0

### 19.2.2 typeid运算符

```C++
typeid(e);//e可以是任意表达式或类型的名字，返回一个常量对象的引用
```

typeid运算符可以作用于任意类型的表达式

- 顶层const被忽略
- 如果表达式是一个引用，则typeid返回该引用所引对象的类型。
- 当typeid作用于数组或函数时，不会执行向指针的标准类型转换，如果我们对数组a执行typeid(a)，则所得的结果是数组类型而非指针类型。
- 当运算对象不属于类类型或者是一个不包含任何虚函数的类时，typeid运算符指示的是运算对象的静态类型。
- 而当运算对象是定义了至少一个虚函数的类的左值时，typeid的结果直到运行时才会求得。

**使用typeid运算符**

```C++
//比较两个表达式是否同类型，或者判断一个表达式是否是指定类型
Derived *dp = new Derived;
Base *bp = dp; //两个指针都指向Derived对象

//在运行时比较两个对象的类型
if (typeid(*bp) = typeid(*dp)) 
{
// bp 和dp指向同一类型的对象
}

//检查运行时类型是否是某种指定的类型
if(typeid(*bp) = typeid (Derived)) 
{
//bp实际指向Derived对象
}

//typeid应该作用于对象而不是指针
//错误: bp的类型是指向Base的指针，比较的是Base*和Derived
if (typeid (bp) == typeid (Derived)) 
{
//此处的代码永远不会执行
}
//当typeid作用于指针时(而非指针所指的对象),返回的结果是该指针的静态编译时类型。

```

- 只有当类型含有虚函数时，编译器才会对表达式求值。
- 如果类型不含有虚函数，则typeid返回表达式的静态类型
- 如果表达式的动态类型可能与静态类型不同，则必须在运行时对表达式求值以确定返回的类型。
- 如果p是一个空指针，则typeid(*p)将抛出一个名为bad_typeid的异常。



### 19.2.3 使用RTTI （运行时类型识别）

例子见书P732

### 19.2.4 type_info类

![image-20210108152659491](./Typora_img/image-20210108152659491.png)

type_info 类没有默认构造函数，它的拷贝和移动构造函数以及赋值运算符都被定义成删除的

**创建type_info对象的唯一途径是使用typeid运算符。**

type_info 类的name成员函数返回一个C风格字符串，表示对象的类型名字。

对于某种给定的类型来说，name的返回值因编译器而异并且不一定与在程序中使用的名字一致。

对于name返回值的唯一要求是， 类型不同则返回的字符串必须有所区别。



## 19.3 枚举类型

枚举属于字面值常量类型

C++包含两种枚举：限定作用域的（C++11标准）和不限定作用域的。

```C++
//限定作用域的枚举类型，通过关键字class
enum class open_modes {input, output, append};
//枚举类型名为open_modes,成员有三个

//不限定作用域的枚举类型，
enum color {red, yellow, green};

//未命名的，不限定作用城的枚举类型
enum {f1oatPrec = 6, Prec1 = 10, Prec2 = 10};

//如果enum是未命名的，则我们只能在定义该enum时定义它的对象

```



 **枚举成员**

限定作用域的枚举类型，其作用域规则遵行一般规则

不限定作用域的枚举类型，枚举成员的作用域与枚举类型本身的作用域相同:

```C++
enum color {red, yellow, green}; //不限定作用域的枚举类型
enum stoplight {red, yellow, green}; //错误:重复定义了枚举成员
enum class peppers {red, yellow, green}; //正确:枚举成员被隐藏了
color eyes = green; //正确:不限定作用域的枚举类型的枚举成员位于有效的作用域中
peppers P = green; // 错误: peppers的枚举成员不在有效的作用城中
// color::green 在有效的作用城中，但是类型错误

color hair = color::red; //正确:允许显式地访问枚举成员
上式也可以写成color hair=red;
peppers p2 = peppers::red; //正确:使用pappers的red

```

枚举值从0开始，依次+1，也可以指定专门的值

```C++
enum class intTypes 
{
charTyp = 8, shortTyp = 16, intTyp = 16，longTyp = 32,string
};
//如果我们没有显式地指定初始值，则当前枚举成员的值等于之前枚举成员的值加1，如string的枚举值就是33

//枚举成员是const的，枚举成员本身就是一个常量表达式，可以用在任何需要常量表达式的地方
```

**和类一样，枚举也定义新的类型**

只要enum有名字，就可以把他当作一个类来使用

```C++
open_modes om = 2; //错误: 2不属于类型open_modes
om = open_modes::input; //正确: input是open_modes的一个枚举成员
//为enum对象赋值时，必须使用枚举成员或另一个enum对象
```

一个不限定作用域的枚举类型的对象或枚举成员自动地转换成整型。

```C++
int i = color::red; // 正确:不限定作用域的枚举类型的枚举成员隐式地转换成int
int j = peppers::red;// 错误:限定作用城的枚举类型不会进行隐式转换

```

**指定enum的大小**

对于限定作用域的enum，如果没有指定enum的潜在类型，则枚举成员默认为int，不限定作用域的枚举类型没有默认类型，可以指定enum的枚举成员类型

```C++
enum intValues : unsigned long long 
    //枚举成员是unsigned long long类型
{
longTyp = 4294967295UL，
};

```

**枚举类型的前置声明**

```C++
//enum的前置声明必须指定其成员的类型(枚举成员的类型)

enum intValues : unsigned 1ong long; // 不限定作用域的，必须指定成员类型
enum class open_modes;//限定作用域的枚举类型可以使用默认成员类型int
//声明和定义的枚举类型必须一致，不存在隐式转换
//不能在同一个上下文中先声明一个不限定作用域的enum名字，然后再声明一个同名的限定作用域的enum:


enum class intValues; //错误:所有的声明和定义必须对该enum是限定作用域的还是不限定作用城的保持一致
enum intValues; //错误:intValues已经被声明成限定作用域的enum
enum intValues : long;//错误: intValues已经被声明成int

```

**形参匹配与枚举类型**

不能将整型值实参传给枚举类型或枚举成员的形参，即使他们值相等

```C++
enum Tokens {INLINE = 128，VIRTUAL = 129};
void ff(Tokens);
void ff(int);
int main() 
{
Tokens curTok = INLINE;
ff(128); //精确匹配ff (int)
ff(INLINE); //精确匹配ff(Tokens)
ff(curTok); //精确匹配ff(Tokens)
return 0;
}

```

可以将一个不限定作用域的枚举类型的对象或枚举成员传给整型形参。此时，enum的值提升成int或更大的整型

```C++
void newf (unsigned char);
void newf (int) ; 
unsigned char uc = VIRTUAL;
newf (VIRTUAL) ;//调用newf (int)
//虽然VIRTUAL可以转换成unsigned char，但是编译器也不会这么做，最低都是提升到Int
newf (uc) ;//调用newf (unsigned char)
```

枚举成员可以传给整型形参，但是整型不能传给枚举类型形参

## 19.4 类成员指针

成员指针是可以指向类的非静态成员的指针，注意这里的成员不是一个对象，直到使用成员指针时，我们才提供成员所属的对象

（静态成员不属于任何对象，不需要指向静态成员的指针）

### 19.4.1 数据成员指针

 成员指针必须包含所属的类

```C++
//必须在*之前加classname::表示当前指针可以指向classname的成员

const string Screen::*pdata;
// pdata 可以指向一个常量(非常量) Screen对象的成员，该成员是const string类型
pdata = &Screen::contents;
//令 pdata指向某个Screen对象的contents成员

//C++11新声明方法
auto pdata = &Screen::contents;
```

**使用数据成员指针**

```C++
//只有当解引用成员指针时才提供对象信息
//成员指针访问运算符 .*和->*
Screen myScreen, *pScreen = &myScreen;

auto s = myScreen.*pdata;// .*解引用pdata以获得myScreen对象的contents成员
s = pScreen->*pdata;// ->*解引用pdata以获得pScreen所指对象的contents成员

//相当于先通过解引用*获得是哪个成员，再通过.或->访问成员信息
```

**返回数据成员指针的函数**

数据成员一般是私有的，我们无法直接获得数据成员指针

解决方法：定义一个函数，返回值是指向该成员的指针

```C++
class Screen 
{
public:
// data 是一个静态成员，返回一个成员指针
static const std::string Screen::* data() //返回指向std::string成员的指针
{
    return &Screen::contents;
}
//返回类型是 const std::string Screen::*   
};

//当我们调用data函数时，将得到一个成员指针:
//data()返回一个指向Screen类的contents成员的指针
const string Screen::*pdata = Screen::data();

//获得myScreen对象的contents成员
auto s = myScreen. *pdata;
```

### 19.4.2 成员函数指针

指向成员函数的指针，需要给定指向的函数的 返回类型和形参列表，包括const修饰符，如果成员存在重载，则我们必须显式地声明  函数类型以明确指出我们想要使用的是哪个函数

```C++
char (Screen::*pmf2) (Screen::pos, Screen::pos) const;
pmf2 = &Screen::get;
//Screen::*两端的()必不可少


//错误:试图定义一个普通函数p，返回一个指针，指向Screen类的char成员
//非成员函数不能使用const修饰
char Screen::* p (Screen::pos，Sereen::pos) const;

pmf = &Screen::get;//必须显式地使用取地址运算符
pmf = Screen::get;//错误:在成员函数和指针之间不存在自动转换规则
//对于普通指针来说，上式指针转换是可行的
```

**使用成员函数指针**

```C++
//.*和->*运算符
Screen myScreen, *pScreen = &myScreen; 
//通过pScreen所指的对象调用pmf所指的函数
char c1 = (pScreen->*pmf) ();

//通过myScreen对象将实参0，0传给含有两个形参的get函数
char c2 = (myScreen.*pmf2) (0,0);

myScreen.*pmf() //错误，试图调用一个名为pmf的函数，认为函数的返回值是一个成员函数指针，然后解引用 应该是myScreen.*pmf
注意运算符号的优先级
```

**使用成员指针的类型别名**

```C++
//Action是成员函数指针别名
using Action =char (Screen::*) (Screen::pos, Screen::pos) const;
//Action是指向Screen类的常量成员函数的指针，
Action get = &Screen::get; //get指向Screen的get成员

//类型别名可用作其他函数的返回类型或形参类型
// action接受一个Screen的引用，和一个指向Screen成员函数的指针
Screen& action (Screen&，Action = &Screen::get) ;

Screen myScreen;

action (myScreen); //使用默认实参
action (myScreen, get); //使用我们之前定义的变量get
action (myScreen, &Screen::get); //显式地传入地址

```

**成员指针函数表***

```C++
//1.类的定义
class Screen 
{
public: 
Screen& home();//光标移动函数
Screen& forward();
Screen& back();
Screen& up();
Screen& down();
    
using Action = Screen& (Screen::*) ();// Action是一个指针，可以用任意一个光标移动函数对其赋值
enum Directions { HOME, FORWARD, BACK，UP，DOWN };//指定具体要移动的方向，
Screen& move (Directions);//定义一个move函数，可以调用上面任意的一个函数
private:
static Action Menu[];//函数表
 
};

//2.初始化函数表
Screen::Action Screen::Menu[] = 
{
&Screen::home,
&Screen::forward,
&Screen::back,
&Screen::up,
&Screen::down, 
};

//3.move函数定义
Screen& Screen::move (Directions cm)
{//运行this对象中索引值为cm的元素
return (this->*Menu[cm]) ();// Menu[cm]指向一个成员函数
 //下标cm是一个整型值
}

//4.调用
Screen myScreen;
myScreen.move (Screen::HOME); // 调用myScreen.home
myScreen.move (Screen::DOWN); // 调用myScreen.down

```

### 19.4.3 将成员函数用作可调用对象

成员指针不是一个可调用对象，不能直接将一个指向成员函数的指针传递给算法

```C++
auto fp = &string::empty; // fp 指向string的empty函数
find_if (svec.begin()，svec.end(), fp);//错误，必须使用.*或->*调用成员指针

if (fp(*it))//错误:要想通过成员指针调用函数，必须使用->*运算符
```

**使用function生成一个可调用对象**

```C++
function<bool (const string&)>fcn = &string::empty;
//第一个形参bool是empty函数的返回值，第二个形参(const string&)是 empty函数的形参
find_if (svec.begin(),svec.end(),fcn);

vector<string*> pvec;
function<bool (const string*)> fp = &string::empty; 
//fp 接受一个指向string的指针，然后使用->*调用 empty
find_if(pvec.begin(),pvec.end(),fp);

```

**使用men_fn生成一个可调用对象**

```C++
//mem_fn 可以根据成员指针的类型推断可调用对象的类型，而无须用户显式指定
find_if (svec.begin(),svec.end(),mem_fn(&string::empty));

//mem_fn生成的可调用对象可以通过对象调用，也可以通过指针调用:
auto f = mem_fn(&string::empty); // f接受一个string或者一个string*,因为empty接受这两种形参
f(*svec.begin()); //正确:传入一个string对象，f使用.*调用empty
f(&svec[0]);  //正确:传入一个string的指针，f使用->*调用empty

```

**使用bind生成一个可调用对象**

 ```C++
//选择范围中的每个string,并将其bind到empty的第一个隐式实参上
auto it = find_if(svec.begin(),svec.end(),bind(&string::empty,_1));
//bind必须将执行对象的隐式形参转换成显式的(_1),即_1代表所绑定的对象

auto f = bind(&string::empty, _1);
f(*svec.begin()); //正确:实参是一个string, f使用.*调用empty
f(&svec[0]); //正确:实参是一个string的指针,f使用->*调用empty

 ```

## 19.5 嵌套类

 定义在一个类内部的类称为嵌套类

嵌套类的名字在外层类作用域中是可见的，在外层类作用域之外不可见。

外层类对嵌套类的成员没有特殊的访问权限，同样，嵌套类对外层类的成员也没有特殊的访问权限。

**声明一个嵌套类**

```C++
class TextQuery 
{
  public:
  class QueryResult;//嵌套类稍后定义
};
```

**在外层类之外定义一个嵌套类**

```C++
//嵌套类必须声明在外层类的内部，但是可以定义在外层类的内部或者外部。

//在外层类外部定义嵌套类时，限定符
class TextQuery::QueryResult 
{
//嵌套类可以直接使用外层类的成员，无须对该成员的名字进行限定
}
```

**定义嵌套类的构造函数**

```C++
TextQuery::QueryResult::QueryResult 
(string s,shared_ptr<set<line.no>> p, shared_ptr<vector<string>> f):
sought(s)，lines(p)，file(f) { }
//不管是在外层类中定义还是在外层类外定义都需要加限定符TextQuery::QueryResult::以说明它是一个嵌套类
```

**嵌套类的静态成员定义**

```C++
//如果QueryResult(嵌套类)声明了一个静态成员，则该成员的定义将位于TextQuery的作用域之外。

// QueryResult类嵌套在TextQuery类中，
//下面的代码为QueryResult定义一个静态成员
int TextQuery::QueryResult::static_mem = 1024;

```

**嵌套类作用域的名字查找**

```C++
//因为QueryResult嵌套在TextQuery中，所以TextQuery的query成员可以直接使用名字QueryResult

//返回类型必须指明QueryResult是一个嵌套类，因为返回类型不在外层类的作用域中
TextQuery::QueryResult
TextQuery::query (const string &sought) const 
    //这是外层类的一个成员函数
{
    //函数体内可以中直接访问QueryResult这个名字
}
```

**嵌套类和外层类是相互独立的**

外层类的对象和嵌套类的对象没有任何关系。嵌套类的对象只包含嵌套类定义的成员。

外层类的对象只包含外层类定义的成员，在外层类对象中不会有任何嵌套类的成员。



## 19.6 union：一种节省空间的类

- 一个union可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。
- 当我们给union的某个成员赋值之后，该union的其他成员就变成未定义的状态了。
- 分配给一个union对象的存储空间至少要能容纳它的最大的数据成员。
- union不能含有引用类型的成员
- 默认情况下，union的成员是公有的
- union可以定义构造函数、析构函数和成员函数，但不能定义虚函数，不能作为基类，也不能继承自其他类

**定义union**

```C++
// Token类型的对象只有一个成员，该成员的类型可能是下列类型中的任意一种
union Token 
{//默认情况下成员是公有的
char cval;
int ival;
double dval;
};

```

**使用union类型**

```C++
//初始化一个union
Token first_token = {'a'}; //初始化cval成员
Token last_token; //未初始化的Token对象
Token *pt = new Token; //指向一个未初始化的Token对象的指针

//访问union成员
last_token.cval = 'z';
pt->ival = 42;
//为union的一个数据成员赋值会令其他数据成员变成未定义的状态。
//当我们使用union时，必须清楚地知道当前存储在union中的值到底是什么类型。

```

**匿名union**

```C++
//匿名即未命名的union
union {//匿名union
char cval; 
int ival; 
double dval;
}; //定义一个未命名的对象，我们可以直接访问它的成员
cval = 'c'; //为刚刚定义的未命名的匿名union对象赋一个新值
ival = 42;  //该对象当前保存的值是42

```

匿名union不能包含受保护的成员或私有成员，也不能定义成员函数。

**使用类管理union成员**

缺！

**使用类管理union成员**

缺！

**管理判别式并销毁string**

缺！

**管理需要拷贝控制的联合成员**

缺！

## 19.7 局部类

定义在函数内部的类称为局部类，局部类的所有成员（包括函数在内）都必须完整定义在类的内部。因此，局部类的成员函数一般只有几行代码，

局部类中也不允许声明静态数据成员，因为我们没法定义这样的成员。

**局部类不能使用函数作用域中的变量**

局部类只能访问外层作用域定义的类型名、静态变量以及枚举成员。如果局部类定义在某个函数内部，则该函数的普通局部变量不能被该局部类使用

```C++
int a, val;
void foo(int val)
{
  static int si;
  enum Loc {a=1024，b};
  // Bar 是foo的局部类
  struct Bar 
  {
      Loc locVal;  //正确:使用一个局部类型名
      int barVal; 
      void fooBar (Loc l = a)//正确:默认实参是Loc::a
      {
      barVal = val;   //错误: val是foo的局部变量（形参）
      barVal = ::val; //正确:使用一个全局对象
      barVal = si;     //正确:使用一个静态局部对象
      locVal = b;      //正确:使用一个枚举成员
      }
  }
}
```

**常规的访问保护规则对局部类同样适用**

外层函数对局部类的私有成员没有任何访问特权。只能通过对象访问其公有成员

**局部类中的名字查找**

```C++
//可以在局部类的内部再嵌套一个类。 此时，嵌套类的定义可以出现在局部类之外。不过，嵌套类必须定义在与局部类相同的作用域中。
void foo() 
{
    class Bar 
    {
      public:
      class Nested; // 声明Nested类
    };
     //定义Nested类
    class Bar::Nested //Bar::Nested指明作用域
    {
    };
}

```

局部类内的嵌套类也是一个局部类，必须遵循局部类的各种规定。嵌套类的所有成员都必须定义在嵌套类内部。



## 19.8 固有的不可移植的特性

不可移植的特性是指因机器而异的特性，例如算术类型的大小在不同机器上不一样

因此，当我们将含有不可移植特性的程序从一台机器转移到另一台机器上时，通常需要重新编写该程序。

C++从C继承而来的不可移植的特性：**位域和volatile限定符**

C++新增不可以移植特性：**链接指示**



### 19.8.1 位域

一个位域中含有一定数量的二进制

位域的类型必须是(无符号)整型或枚举类型

```C++
//位域的声明形式是在成员名字之后紧跟一个冒号以及一个常量表达式，该表达式用于指定成员所占的二进制位数:
typedef unsigned int Bit;
class File 
{
   Bit mode: 2; // mode占2位
   Bit modified: 1; // modified占1位
   Bit prot_owner: 3; // prot_owner占3位
   Bit prot_group: 3; // prot_group占3位
   Bit prot_world: 3; // prot_world占3位
// File 的操作和数据成员
public:
   //文件类型以八进制的形式表示
   enum modes { READ = 01，WRITE = 02, EXECUTE = 03 };
   File fopen (modes);
   void close();
   void write();
   bool isRead () const;
   void setWrite();
};
//如果可能的话，在类的内部连续定义的位域压缩在同一整数的相邻位，从而提供压缩存储
//上面的声明中，五个位域可能会存储在同一个unsigned int中。

```

**使用位域**

```C++
void File::write()
{
  modified = 1;
}

void File::close()
{
  if(modified)
  {
  }
}
//使用内置的位运算符操作超过1位的位域
File &File::open (File::modes m)
{
   mode |= READ;  //按默认方式设置READ
   if (m & WRITE)  //如果打开了READ和WRITE
   return *this;
}

//检验或设置位域的值
inline bool File::isRead() const { return mode & READ; }
inline void File::setwrite() { mode 1= WRITE; }

```

### 19.8.2 volatile限定符


当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为volatile。关键字volatile告诉编译器不应对这样的对象进行优化。

```C++
//volatile限定符的用法和const很相似，它起到对类型额外修饰的作用:
volatile int display_register;  //该int值可能发生改变
volatile Task *curr_ task; // curr_task指向一个volatile对象
volatile int iax [max_ size]; // iax 的每个元素都是volatile
volatile sereen bitmapBuf; // bitmapBuf 的每个成员都是volatile

```

类可以将成员函数定义成volatile的。volatile的对象只能调用volatile的成员函数。

```C++
//我们可以声明volatile指针、指向volatile对象的volatile int v;
volatile int v; // v是一个volatile int
int *volatile vip; // vip 是一个volatile指针，它指向int
volatile int *ivp; // ivp是一个指针，它指向一个volatile int
volatile int *volatile vivp;// vivp是一个volatile指针，它指向一个volatile int
int *ip = &v; //错误：必须使用指向volatile的指针
ivp = &v;  //正确: ivp是一个指向volatile的指针
vivp = &v; //正确: vivp是一个指向volatile的volatile指针

```

和const一样，我们只能将一个volatile对象的地址赋给一个指向volatile的指针。同时，只有当某个引用是volatile的时，我们才能使用一个volatile对象初始化该引用。

**合成的拷贝对volatile对象无效**

我们不能使用合成的拷贝/移动构造函数及赋值运算符初始化volatile对象或从volatile对象赋值。因为合成的成员接受的形参类型是常量引用而不是volatile引用，显然我们不能把一个volatile对象传给非volatile形参。

如果一个类希望拷贝、移动或赋值它的volatile对象，则该类必须自定义拷贝或移动操作，且将形参类型指定为const volatile 引用

```C++
class Foo {
public:
Foo (const volatile Foo&); //从一个volatile对象进行拷贝
Foo& operator= (volatile const Foo&);//将一个volatile对象赋值给一个非volatile对象
Foo& operator= (volatile const Foo&) volatile;//将一个volatile对象赋值给一个volatile对象
}
//volatile与const顺序随意
```

### 19.8.3 链接指示：extern"C"

**声明一个非C++的函数**

链接指示不能出现在类定义或函数定义的内部。同样的链接指示必须在函数的每个声明中都出现。

```C++
//可能出现在C++头文件<cstring>中的链接指示
//单语句链接指示
//下面函数可以被C程序调用
extern "C" size_t strlen (const char *);

//复合语句链接指示
extern "C"
{
int strcmp (const char*, const char*);
char *strcat (char*, const char*);
}
//编译器也可能会支持其他语言的链接指示，如extern "Ada" extern"FORTRAN"等。

```

**链接指示与头文件**

```C++
//多重声明的形式可以应用于整个头文件。例
//复合语句链接指示
extern "C" 
{
#include <string.h> //操作C风格字符串的C函数
}

```

当一个#include指示被放置在复合链接指示的花括号中时，头文件中的所有普通函数声明都被认为是由链接指示的语言编写的。链接指示可以嵌套，因此如果头文件包含带自带链接指示的函数，则该函数的链接不受影响。

**指向extern"C"函数的指针**

如果指针指向了一个声明了extern"C"的函数，那么指针的声明和定义也必须加上“extern "C" ”修饰符

```C++
extern "C" void (*pf) (int);// pf指向一个C函数，该函数接受一个int返回void
//当我们使用pf调用函数时，编译器认定当前调用的是一个c函数。


//如果试图在两个链接指示不同的指针之间进行赋值操作，则程序将发生错误:
void (*pf1) (int); //指向一个C++函数
extern "c" void (*pf2) (int); //指向一个c函数
pf1 = pf2; //错误: pf1和pf2的类型不同

```

**链接指示对整个声明都有效**

当我们使用链接指示时，它不仅对函数有效，而且对作为返回类型或形参类型的函数指针也有效:

```C++
// f1是一个C函数，它的形参是一个指向c函数的指针
extern "C" void f1 (void(*) (int));
//当我们调用f1时，必须传给它一个c函数的名字或者指向c函数的指针。
```

```C++
//一个指向C函数的指针传给接受C++函数的形参，必须使用类型别名

extern "C" typedef void FC(int); // FC是一个指向c函数的指针
void f2(FC *); //f2是一个C++函数，该函数的形参是指向c函数的指针
```

**导出C++函数到其他语言**

```C++
//令一个C++函数在其他语言编写的程序中可用: 
extern "C" double calc (double dparm) { /* ...*/ }// calc 函数可以被C程序调用
//编译器为该函数生成C语言的代码
```

**对链接到C的预处理器的支持**

```C++
#ifdef __cplusplus //正确:我们正在编译C++程序
extern "C"
#endif
//如果是__cplusplus为真，表示当前是C++程序，extern"C"声明不执行
//否则，extern"C"执行，告诉编译器需要编译C语言代码
```

**重载函数与链接指示**

C语言不支持函数重载，因此一个C链接指示只能用于说明一组重载函数中的某一个:

```C++
//错误:两个extern "C"函数的名字相同
extern "C" void print (const char*);
extern "C" void print (int);

```

如果在一组重载函数中有一个是 C函数，则其余的必定都是C++函数:

```C++
class Smal1Int { /* ...*/ };
class BigNum { /*..*/ };


extern "C" double calc (double);// 此函数是C函数，可以在C或C++程序中调用
// 下面的函数是C++函数，是上面函数的重载，且形参用了C++中的类类型，而C不能识别类，所以只能在C++程序中调用
extern Smal1Int calc (ccnst SmallInt&); 
extern BigNum calc (const BigNum&);

```

**注意：不能把包含类类型参数的C++语句，传给C程序(声明成extern "C")，因为C程序无法理解构造函数、析构函数和其他类特有的操作**