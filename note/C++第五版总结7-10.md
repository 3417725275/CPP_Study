#  7.类

## 7.1 定义抽象数据类型

### 7.1.1设计Sales_data类

### 7.1.2 定义改进的Sales_data类

成员函数的声明必须在类的内部，它的定义既可以在类的内部也可以在类的外部

定义在类内部的函数是隐式的inline函数（问：如果函数的代码较多怎么办，是否展开比较麻烦）

**this指针**

- 对类成员的直接访问被看作是this的隐式调用，
- 任何自定义名为this参数或变量的行为都是非法的，
- this指针是一个常量指针，不能够改变this中保存的地址

**引入const成员函数**

默认情况下，this的类型是指向类类型非常量版本的常量指针

即，this本身是常量，但它指向的对象未必是常量，顶层const，无底层const

因此，我们不能把this 绑定到一个常量对象

因此，**常量对象不能调用普通的成员函数**

如何把this指针声明成指向常量的常量指针

例如const Sales_data *const，如何设置？

紧跟在成员函数参数列表后面的const表示this是一个指向常量的指针，像这样使用const的成员函数被称作**常量成员函数**

```C++
//伪代码，说明隐式的this指针是如何使用的
//下面的代码非法，不能自己显式定义this指针
std::string Sales_data::isbn(const Sales_data *const this)
{
    return this->isbn;
}

//正确声明底层const this指针
std::string Sales_data::isbn() const;
```

**常量成员函数**认为调用它的对象是常量对象，因此成员函数不能改变调用它的对象的内容，只能读取对象的数据成员

- **常量对象、以及常量对象的引用或指针都能只能调用常量成员函数，不能调用普通成员函数**
- 普通对象，及对象的引用和指针既可以调用普通成员函数也可以把调用const成员函数

**类作用域和成员函数**

编译器首先编译成员的声明，然后才轮到成员函数体，因此成员函数可以随意使用类中的其他成员而无需注意这些成员出现的次序

**在类的外部定义成员函数**

```C++
double Sales_data::avg_price() const
{
    if(units_sold)
        return revenue/units_sold;
    else
        return 0;
}
//::作用域运算符，表示函数avg_price被声明在类Sales_data中，一旦编译器看到这个函数名，剩余代码表示位于类的作用域内。
//所以avg_price使用revenue和units_sold时，实际上隐式使用了Sales_data的成员

```

**定义一个返回this对象的函数**

```C++
Sales_data& Sale_data::combine(const Sales_data &rhs)
{
    units_sole+=rhs.units_sold;
    revenue+=rhs.revenue;
    return *this;
    //this是指针，*this才是存放的对象
}
//调用
total.combine(trans);
//total的地址被绑定到隐式的this参数上，相当于把total和trans相加，返回的内容赋给total
//该函数相当于返回total的引用。返回引用的函数可以作左值
```



## 7.1.3 定义类相关的非成员函数

如果函数在概念上属于类但是不定义在类中，则它一般与类声明在同一个头文件中，称为非成员函数

（补充：IO类属于不能拷贝的类型，因此必须通过引用来传递它们）



### 7.1.4构造函数

构造函数不能被声明成const

创建类的对象时，直到构造函数完成初始化过程，对象才真正获得其常量属性。因此，构造函数在const对象的构造过程中可以改变其数据成员的值

**合成的默认构造函数**

如果我们的类没有显示地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数。这个函数又称**合成的默认构造函数**

- 如果存在类内初始值，用它来初始化成员

```C++
class CC
{
public:
    CC() {}
    ~CC() {}
private:
    int a = 7; // 这就是类内初始值
}
```

- 否则，默认初始化该成员

**某些类不能依赖于合成的默认构造函数**

对于一个普通的类来说，必须定义它自己的默认构造函数，因为

- 因为有时候需要通过构造函数实现对成员的初始化
- 对于某些类来说，合成的默认构造函数可能执行错误的操作

如果类包含有内置类型或复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适合使用合成的默认构造函数，否则用户在创建类的对象时就可能得到未定义的值。

- 编译器有时候不能为某些类合成默认的构造函数

如果一个类中包含了其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。对于这样的类来说，我们必须自定义默认构造函数，否则该类将没有任何可用的默认构造函数。

**=default**

C++11新标准中，可以通过在参数列表后面写上=default来要求编译器生成默认构造函数。

```C++
Sales_data()=default;//默认构造函数
```

如果=default在类内部（作为声明），则默认构造函数是内联的，如果它在类的外部（作为定义），则该成员默认情况下不是内联的。

**构造函数初始值列表**

```C++
Sales_data(const std::string &s):bookNo(s),units_sold(0),revenue(0){ }
//当某个数据成员被构造函数初始值列表忽略时，它将以合成默认构造函数相同的方式隐式初始化。

//！！有的编译器不支持类内初始值，此时所有的构造函数都应该显示地初始化（列表初始化）每个内置类型的成员
```

**在类的外部定义构造函数**

在类外部定义构造函数时，必须指明该构造函数是哪个类的成员

- 没有构造函数初始值列表时，通过相应的类内初始值初始化
- 如果没有类内初始值，则执行默认初始化。

### 7.1.5 拷贝、赋值和析构

如果我们不主动定义拷贝、赋值和析构操作时，编译器将替我们合成他们

编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作。



**某些类不能依赖于合成的版本**

如果类包含vector或string成员，则拷贝、赋值和销毁的合成版本能够正常工作，赋值或拷贝操作时，vector中成员的值也进行拷贝和赋值，销毁时也同时销毁

含有指针数据成员的类一般不宜使用默认的拷贝和赋值操作（会存在深浅拷贝问题），

如果类的数据成员都是内置类型的，则不受干扰

## 7.2访问控制与封装

类的定义可以采用class和struct关键字，唯一的区别是默认访问权限不同

class默认访问权限是private，struct默认访问权限是public；



### 7.2.1 友元

友元函数的声明只能出现在类定义的内部，具体位置不限，**友元不是类的成员也不受它所在区域访问控制级别的约束**

```C++
Class A
{
Friend int ComputerRectArea(CRectangle & myRect);//声明为友元函数
}
//则该函数能够访问类A里的私有成员
```

一些编译器允许在尚无友元函数的初始声明的情况下就调用它，但是还是建议提供一个独立的函数声明

## 7.3类的其他特性

- 类型别名可以隐藏成员的类型信息

```C++
class Screen
{
    public:
    typedef std::string::size_type pos;
    //等价声明 using pos=std::string::size_type;
    private:
    pos cursor=0;
    pos height=0;
    std::string contents;
}
//这样对象就不知道Screen用了一个string对象来存放它的cursor数据
```

**令成员作为内联函数**

定义在类内部的成员函数默认是inline的

如果成员函数在类外部定义，可以

- 在类内部成员函数声明的前面加上inline
- 在类外部成员函数定义的地方，前面加上inline

```C++
inline char Screen:get() {retun ...}
```

无须在声明和定义的地方同时说明inline

建议inline成员函数与相应的类定义在同一个头文件中

**重载成员函数**

**可变数据成员**

通过在变量的声明中加入mutable关键字，使得const成员函数也可以改变它的值

```C++
class Screen()
{
    public:
    void some_member() const;
    private:
    mutable size_t access_ctr;//在const成员函数中也可以改变其值
}
```

### 7.3.2 返回*this的成员函数

return *this：返回对象本身的引用

```C++
//版本1，返回Screen &
inline Screen & Screen::set()
{
    return *this;
}
//版本2，返回Screen
inline Screen Screen::set()
{
    return *this;
}
//myScreen是一个对象
Screen temp=myScreen.set()//调用版本2,返回的是对象的副本
myScreen.set()//调用版本1，返回对象本身的引用，即myScreen
//调用后返回的值又赋值给了myScreen
```

**从const成员函数返回*this**

一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用

```C++
const Screen &Screen::set() const
{
    return *this;
}
//该函数的范围类型是const Screen &
```

**基于const的重载**

根据this指针指向是否是const可以实现函数重载

即const函数和非const函数是两个函数

```C++
class Screen
{
    public:
    Screen &display(std::ostream &os)
    {
        do_display(os);
        return *this;
    }//非常量版本
    const Screen &display(std::ostream &os) const
    {
        do_display(os);
        return *this;
    }//常量版本，函数重载
    
    private:
    void do_display(std::ostream &os) const
    {
        os<<contents;
    }
}

//当非常量版本display调用do_display时，display的this指针指向的是非常量对象，隐式转换成指向常量的指针
//do_display完成后，非常量版本的display返回的是一个非常量对象，该版本返回的是普通类的引用，常量版本返回的是常量引用。

//根据调用的对象是否是const，决定使用哪个版本的display。

这里do_dispaly相当于把display两个版本的公共部分提取出来了，
两个display实现其中有差别的功能
```

### 7.3.3类类型

两个类即使即使成员完全一样，但类名不一样，那也是两个类型

 ```C++
Sales_data item1;//默认初始化Sales_data类型的对象
class Sales_data item1;//等价声明，C风格语句
 ```

**类的声明**

```C++
class Screen;//Screen类的声明
//前向声明：
//在声明之后——定义之前是一个不完全类型：不清楚该类包含哪些成员
//可以定义指向这种类型的指针或引用，也可以声明以不完全类型作为参数或者返回类型的函数，但只有类被定义的时候，才能够通过引用和指针访问其成员

//但是，在创建类的对象之前，它必须被定义过，而不能仅仅被声明，因为编译器需要计算该对象需要多少存储空间。
```

- 一个类的成员类型不是能该类自己，但一旦类的名字出现后，它被认为是声明过了，但可以尚未定义，因此允许类包含指向自身类型的引用或指针

```C++
class Link_screem
{
    Screen window;
    Link_screen *next;
    Link_screen *prev;//正确
    Link_screen pdb;//错误，不能定义对象
}
```

### 7.3.4友元再探

```C++
Class CItem
{
friend class CList; //把CList作为友元类
//则CList中的所有方法都可以访问CItem类中的成员包括非公有成员
}
//友元不存在传递性
```

**令成员函数作为友元**

```C++
class Screen//相当于声明
{
    friend void Window_mgr::clear();//Window_mgr是类名
    //这样clear函数就能访问Screen中的私有成员
}
```

**声明友元函数的顺序**

- 1.首先定义Window_mgr类，其中声明了clear函数，但是不能定义它？
- 2.在clear使用Screen的成员之前必须先声明Screen
- 3.接下来定义Screen，包括对clear的友元声明
- 4.最后定义clear，此时它才可以使用Screen的成员

**函数重载和友元**

如果一个类想把一组重载函数声明成它的友元，需要对这组函数中的每一个分别声明

```C++
extern std::ostream& storeOn(std::ostream&,Screen &); //1.
extern Bitmap& storeOn(BitMap &,Screen &);
class Screenn //2.
{
    //3.
    friend std::ostream& storeOn(std:: ostream&,Screen &);
    friend Bitmap& storeOn(BitMap &,Screen &);
    //如此，两个重载函数才能访问Screen的成员
}
//4.
std::ostream& storeOn(std:: ostream&,Screen &)
{
    
}
```

**友元声明和作用域**

```C++
//在类中定义或声明了友元函数，但该友元函数本身不一定真的声明在当前作用域中。
//比如在类的外部提供相应的声明，然后才能调用该函数
//即使我们用类调用类中的声明友元函数，该友元函数也必须在外部声明一次；
strcut X
{
    friend void f(){}//友元函数
    x() {f();}//错误，f还没有被声明
    void g();
    void h();
};
void X::g(){return f();}//错误，f还没有被声明
void f();//声明那个定义在X中的函数
void X::h(){return f()};
//有些编译器并不强制执行上述关于友元的先定规则;
```

## 7.4类的作用域

 ```C++
Screen::pos i=1,j=2;//使用Screen中定义的pos类型定义变量
Screen scr(i,j,' ');
Screen *p=&scr;
char c=scr.get();//通过对象访问成员函数
c=p->get();//通过指向对象的
 ```

**作用域和定义在类外部的成员**

一个类就是一个作用域，一旦遇到了类名，定义的剩余部分就在类的作用域之内了。

```C++
//例如成员函数在外部的定义
void Window_mgr::clear(ScreenIndex i)
{
    //出现了window_mgr，则后面部分及函数体内的作用域都在类中
    //因此这里可以访问类的成员
    Screen &c=screens[i];
    //这里的Screen也是在Window_mgr中定义的
}
//返回类型在类名字前面，因此返回类型中使用的名字都位于类的作用域之外,这时返回类型必须指明它是哪个类的成员
Window_mgr::ScreenIndex Window_mgr::addScreen(const Screen &s){}// 前面的是返回类型
//返回类型位于window_mgr类的作用域之外，想要使用ScreenIndex作为返回类型，必须明确指定哪个类定义了它
```

 ### 7.4.1 名字查找与类的作用域

   ```C++
//名字查找顺序
首先，在名字所在块中寻找声明语句，只考虑在名字的使用之前出现的声明
如果没找到，继续查找外层作用域
如果最终没找到，程序报错
    
//类中名字解析有所区别
编译器处理完类中的全部声明后才会处理成员函数的定义
//因为成员函数体直到整个类可见后才会被处理，所以它能使用类中定义的任何名字
//这种查找方式只适用于成员函数
   ```

**用于类成员声明的名字查找**

```C++
//对于类中声明语句使用的名字，必须确保在使用前可见
typedef double Money;
string bal;
class Account
{
    public:
    Money balance(){retun bal;}
    private
        Money bal;
}
//关于Money名字的查找
//首先在类作用域中查找对Money的声明，只考虑出现在使用Money之前出现的声明
//然后再到外层作用域中查找
//在这个例子中，找到的是typedef语句，所以balance的返回值和bal的类型都是使用的typedef声明的Money
```

**类型别名要特殊处理**

  ```C++
//在类中，如果成员使用了外层作用域中的某个名字，而该名字代表了一种类型，则类不能在之后重新定义该名字:
typedef double Money;
class Account
{
    public:
    Money balance(){return bal;}//使用外层作用域的Money
    private:
    typedef double Money;//错误，不能重新定义Money
    Money bal;
    //....
}
//即使Account中定义的Money类型与外层类型一致，但也是错的
//类型名的定义通常出现在类开始的地方，这样就能确保所有使用该类型的成员都出现在类名的定义之后。
  ```

**成员定义中的普通块作用域的名字查找**

 ```C++
//成员函数中使用的名字按照如下方法解析
首先在成员函数内查找该名字，只有在名字使用之前出现的声明才被考虑
如果成员函数内没有找到，则在类中继续查找，这时类的所有成员都可以被考虑
如果类中也没有找到，在成员函数定义之前的作用域内继续查找
//例
int height;
class Screen
{
    public:
    typedef sdt::string::size_type pos;
    void dummy_fcn(pos height)
    {
        cursor=width*height;//哪个height，是哪个参数
 //首先在函数体内查找，这里的height是参数声明
 //这意味着参数声明隐藏了同名的类成员
    }
    private:
    pos cursor=0;
    pos height=0,width=0;
}
//如果要调用类中的成员，则13行变为
cursor=width*this->height;//法1
cursor=width*Screen::height;//法2
//建议的写法：
void dummy_fcn(pos ht)
{
 cursor=width*height;   
}
 ```

**类作用域之后，在外围的作用域中查找**

上面的例子，如果在函数和类的作用域中都没有找到名字，它将接着在外围的作用域中查找，在上面的例子中，Screen中定义的height成员隐藏了外层作用域中的height，因此，如果需要调用外层作用域的height，可以使用

```C++
void Screen::dummy_fcn(pos height)
{
    cursor=width*::height;//全局的height
}
```

 **在文件中名字的出现处对其进行解析**

当成员定义在类的外部时，名字查找的第三步不仅要考虑类定义之前的全局作用域中的声明，还需要考虑在成员函数定义之前的全局作用域中的声明                  

## 7.5构造函数再探

### 7.5.1 构造函数初始值列表

```C++
//在构造函数内部初始化成员
Sale_data::Sales_data(const string &s,unsigned cnt,double price)
{
    bookNo=s;
    units_sold=cnt;
    revenue=cnt*price;
}
```

 **构造函数的初始值有时必不可少**

```C++
//如果成员时const或者引用的话，必须将其初始化
class
{
    private:
    int i;
    const int ci;//错误，const变量需要初始化
    int &ri;//引用需要初始化
}
//如果成员是const、引用或者属于某种未提供默0认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初始值
ConstRef::ConstRef(int ii):i(ii),ci(ii),ri(i){ }
//建议养成使用构造函数初始值的习惯
```

**成员初始化的顺序**

```C++
//成员的初始化顺序与它们在类定义中的出现顺序一致，第一个定义的成员先被初始化
//构造函数初值列表中初始值的前后位置关系不会影响实际的初始化顺序
class X
{
    int i;
    int j;
    public:
    X(int val):j(val),i(j){}//错误
}
//这里实际上应该是先i初始化，再j初始化，所以试图用未定义的j初始化i
X(int val):i(val),j(i);//正确

//最好令构造函数初始值顺序与成员声明的顺序保持一致，尽量避免使用某些成员初始化其他成员
```

**默认实参和构造函数**

```C++
class Sales_data
{
    public:
    Sales_data(std::string s=" "):bookNo(s){ }
}
//如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数
```

### 7.5.2 委托构造函数

 ```C++
//C++11标准，一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程
class Sales_data
{
    public:
    //非委托构造函数使用对应的实参初始化成员
    Sales_data(std:string s,unsigned cnt,double price):
           bookNo(s),units_sold(cnt),revenue(cnt*price){ }
    //其余的构造函数全部委托给上面的构造函数
    Sales_data():Sales_data("",0 ,0){}
    Sales_data(std::string s):Sales_data(s,0,0){}
    Sales_data(std::istream &is):Sales_data() {read(is,*this)}
}
 ```

### 7.5.3默认构造函数的作用

**默认初始化**

- 当块作用域内不使用任何初始值定义一个非静态变量或数组时
- 当一个类本身含有类类型的成员且使用合成的默认构造函数时
- 当类类型的成员没有在构造函数的初始值列表中显式的初始化

**值初始化**

- 数组初始化的过程中，提供的初始值少于数组的大小
- 不使用初始值定义一个局部静态变量
- 通过书写形式T()的表达式显式地请求初始值，其中T是类型名

**在实际中，如果定义了其他构造函数，最好也提供一个默认构造函数**

```C++
class Sales_data
{
    Sales_data();//默认构造函数
}
Sales_data obj;//调用默认构造函数
Sales_data obj();//错误，声明了一个函数而非对象
```

### 7.5.4隐式的类类型转换 

**能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则**

```C++
//前提，存在一个以string类型为参数的构造函数
Sales_data(std::string s);
Sales_data &Sales_data::combine(const Sales_data &rhs)
{
 units_sole+=rhs.units_sold;   
}
string null_book="9-999-9999-9";
item.combine(null_book);
//这里用string实参调用了形参是Sales_data的对象，这样调用是合法的，编译器用给定的string自动创建了一个Sales_data对象，新生成的Sales_data对象传递给combine，因为Combine的参数是一个常量引用，所以我们可以给参数传递一个临时量
```

**只允许一步类类型转换**

```C++
item.combin("9-99-99-9999");
//错误。这里转换需要两步
//先把字面值类型"9-99-99-9999"转换成string类型
//再把临时的string转换成Sales_data,所以不正确

//如果需要这样做，必须显示的把字面值类型转换为string对象，或者显示地把string转换成Sales_data
item.combine(string("9-99-99-9999"));
//正确，显示转换成string，隐式转换成Sales_data
item.combine(Salas_data("9-99-99-9999"));
//正确，隐式转换成string，显示转换成Sales_data
    
```

**类类型转换不是总有效**

```C++
Sales_data(std::istream &s){return(is,*this)}//构造函数
item.combine(cin);
//隐式的把cin转换成Sales_data的临时对象，随后将得到的值传递给combine函数
//当combine调用完后，这个临时的对象被丢弃

```

**抑制构造函数定义的隐式转换**

**我们可以通过将构造函数声明为explicit加以阻止**

```c++
class Sales_data
{
   explicit Sales_data(const std::string &s);
   explicit Sales_data(std::istream &);
}
//此时没有任何构造函数能用于隐式地创建Sales_data对象
item.combine(null_book);//错误，以string为参数的构造函数是explicit的
item.combine(cin);//错误，以istream为参数的构造函数是explicit的
```

- explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以这些函数无须指定为explicit
- 只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复

**explicit构造函数只能用于直接初始化，不能用于拷贝形式的初始化**

```C++
Sales_data item1(null_book);//正确，直接初始化,在定义对象时
Sales_data item2=null_book;//错误，不能将explicit构造函数用于拷贝形式的初始化过程
```

**为转换显式地使用构造函数**

```C++
//为了能够使用explicit的构造函数，可以采用强制转换
item.combine(Sales_data(null_book));//采用构造函数作为实参
item.combine(static_cast<Sales_data>(cin));//执行了显示转换，static_cast使用istream构造函数创建了一个临时的Sales_data对象
```

**标准库中含有显式构造函数的类**

string类含有单参数的构造函数，如string(const char*)；但该构造函数不是explicit的

接受一个容量参数的vector构造函数，vector<type> v(n); 该函数是explicit 的



### 7.5.5 聚合类

用户可以直接访问聚合类的成员，并且具有特殊的初始化语法形式

**一个聚合类满足以条件**

- 所有成员都是public
- 没有定义任何构造函数
- 没有类内初始值
- 没有基类，也没有virtual函数

```C++
//例
struct Data
{
    int val;
    string s;
}
//通过{}初始化聚合类的数据成员
Data val1={0,"Anna"};
Data val1={"Anna",0};//错误，初始值的顺序必须与声明的顺序一致

//如果初始值列表中元素个数少于成员个数，靠后的成员被值初始化
```

### 7.5.6字面值常量类

字面值常量类满足以下要求

- 数据成员都必须是字面值类型
- 类必须至少含有一个constexper构造函数
- 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数
- 类必须使用析构函数的默认定义

**constexpr构造函数**

```C++
//constexpr构造函数体一般来说应该是空的
//constexpr构造函数必须初始化所有数据成员，初始化采用初始值或使用constexpr构造函数，或者是一条常量表达式
//constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或返回类型；
class Debug
{
    constexpr Debug(bool b=true):hw(b),io(b),other(b){}
    private:
    bool hw;
    bool io;
    bool other;
}
```

## 7.6类的静态成员

**声明静态成员**

```C++
//静态成员可以是public或private的
class Account
{
    public:
    static double rate(){}
    private:
    std::string owner;
    double amount;
    static double interestRate;
    static double initRate();
}
//类的静态成员存在于任何对象之外
//任何Account的对象只包含两个数据成员，owner和amount，
//Rate 被所有Account的对象共有
//静态成员函数也不和任何对象绑定在一起，不能声明成const，也不能使用this指针
```

**使用类的静态成员**

```C++
//通过作用域运算符访问静态成员
double r;
r=Account::rate();
//也可以通过类的对象，引用或指针访问静态成员函数
Account ac1;
Account *ac2=&ac1;
r=ac1.rate();
r=ac2->rate();

//成员函数不通过作用域运算符就能直接使用静态成员
class Account
{
    public:
    void calculate(){amount+=amount*interestRate}
    private:
    static double interestRate;
    static double initRate();
}
```

**定义静态成员**

既可以在类的内部也可以在类的外部定义静态成员函数，当在类的外部定义静态成员时，不能重复static关键字，**该关键字只出现在类内部的声明语句**

- 不能在类的内部初始化静态成员，也不是由类的构造函数初始化（这里的成员指变量，函数可以在内部定义）
- 必须在类的外部定义和初始化每个静态成员
- 一个静态数据成员只能定义一次
- 静态数据成员存在于任何函数之外，一直存在于程序的整个生命周期

```C++
class Account
{
    private:
    static double interestRate;
    static double initRate();//声明
}
double Account::interestRate=initRate();//定义静态成员并初始化
//为了防止对象重复定义，建议把静态数据成员的定义与其他非内联函数的定义放在一个文件中
```

**静态成员的类内初始化**

一般情况下不在类内初始化静态成员，但，当静态成员是constexpr的字面值常量类型时，可以通过常量表达式赋初值

```C++
class Account
{
    private:
    static constexpr int period=30;//period是常量表达式
    double daily_tbl[period];
}
//如果类的内部提供了一个初始值，则成员的定义不能再指定一个初始值了
//此时声明和定义相当于一起了
//但是这种情况应该在类的外部再定义一下该成员，但不分开
```

(const 和 constexpr的区别，const只保证了运行时不直接被修改，constexpr在编译的时候就能算出来)

**静态成员特有的适用场景**

- 静态数据成员可以是不完全类型

```C++
class Bar
{
    private:
    static Bar men1;//正确，静态成员可以是不完全类型
    Bar* men2;//正确，指针或引用成员可以是不完全类型
    Bar men3;//错误，数据成员必须是完全类型
}
```

- 静态成员可以作为默认实参，但是非静态数据成员不行

```C++
class Screen
{
    public:
    //bkground表示一个类中稍后定义的静态成员
    Screen & clear(char=bkground);
    private:
    static const char bkground;
}
```

## 7.7 类中静态数据成员的声明和定义

```C++
//只能在类外定义同时赋值，在类中声明。不能再类中声明时赋值！！
class A
{
public:
	static int a;
	static int b;
    static double rate();
};
 
int A::a=1;
int A::b=1;
double A::rate()
{
    .....
}
```



# 8.IO库

## 8.1 IO类

![IO类继承图](./Typora_img/20190711224325250.png?token=ARTDMQ4LGCI53MVYBBWDSGLAQURWI)

![IO类](./Typora_img/50332-20161029112647250-287999006.gif?token=ARTDMQ7ZKM4YOCE7RDWTSA3AQURWM)

**常用的三个头文件iostream，fstream，sstream**

```C++
//istream (输入流)类型，提供输入操作。
//ostream(输出流)类型，提供输出操作。
//cin,一个istream对象，从标准输入读取数据。
//cout,一个ostream对象，向标准输出写入数据。
//cerr,一个ostream对象，通常用于输出程序错误消息，写入到标准错误。
//>>运算符，用来从一个istream对象读取输入数据。
//<<运算符，用来向一个ostream对象写入输出数据。
//getline 函数,从一个给定的istream读取一行数据，存入一个给定的string对象中。
```



**IO类型间的关系**

设备类型和字符大小不影响IO操作，也不用管读取的字符是否能存入一个char对象内，还是需要wchar_t对象来存储。

### 8.1.1 IO对象无拷贝或赋值

**不能拷贝或对IO对象赋值**

```C++
ofstream out1,out2;
out2=out1;//错误，不能对流对象赋值
ofstream print(ofstream);//错误，不能初始化ofstream参数
out2=print(out2);//错误，不能拷贝流对象

//不能将形参或返回类型设置为流类型
//读写一个IO对象会改变其状态，因此传递和返回的引用不能是const
```

### 8.1.2条件状态

```C++
badbit  用来指出流已经崩溃，属于系统级错误，如不可恢复的读写错误。
failbit  表示一个io操作失败了，比如读取数字却读取的是字符，这是可以恢复的
eofbit  用来表示文件达到文件结尾，这也是可以恢复的
goodbit 表示流的状态正常
    
//注意的是，一但流发生错误，其上后续的io操作都会失败，只有流属于无错状态时，我们才可以用来读取数据，写入数据。
    
    
//确定一个流对象状态的最简单的方法是将它当作一个条件来使用
while(cin>>word);//循环检查>>表达式返回的流的状态
```

**查询流的状态**

```C++
s.eof();//若s的eofibit置位，则返回true，表示达到文件末尾
s.fail();//若failbit或badbit置位，返回true
s.bad();//若badbit置位，返回true
s.good();//若s处于有效状态，返回true
s.clear();//将流s中所有条件状态复位，将流状态设置为有效，返回true
s.clear(flags);
s.setstate(flags); //设置状态，flags为strm::iostate类型
s.rdstate();//返回流s的当前条件状态，返回值类型为strm::iostate
```

**管理条件状态**

```C++
auto old_state=cin.rdstate();//记住cin的当前状态
cin.clear();//使cin有效
process_input(cin);//使用cin
cin.setstate(old_state);//将cin置为原有状态

cin.clear(cin.rdstate()& ~cin.failbit & ~cin.badbit)
//将failbit和badbit复位，保持eofbit不变
```

### 8.1.3 管理输出缓冲

缓冲机制：文本串先保存到缓冲区，随后再写入到输出设备中

缓冲刷新：数据真正的写入到输出设备中

- 缓冲区满时，需要刷新缓冲，才能继续写入缓冲区
- endl 可以显式刷新缓冲区
- 写到cerr  (错误流)的内容都是立即刷新的
- 可以用操作符unitbuf设置流的内部状态，来清空缓冲区
- 读写 被关联的流时，关联到的流的缓冲区会被刷新(cin和cerr都关联到cout，因此，读写cin或cerr会刷新cout的缓冲区)

**刷新输出缓冲区**

```C++
cout<<"hi!"<<endl;//输出hi和换行，然后刷新缓冲区
cout<<"hi!"<<flush;//输出hi，然后刷新缓冲区，不附加任何额外字符
cout<<"hi!"<<ends;//输出hi和空字符，然后刷新缓冲区
```

**unitbuf操纵符**

```C++
cout<<unitbuf;//告诉流接下来的每次操作之后都进行一次flush操作
...
cout<<nounitbuf;//重置流，恢复正常的缓冲区刷新机制
```

**如果程序崩溃，输出缓冲区不会被刷新**

**关联输入和输出流**

标准库将cin和cout关联在一起

```C++
cin>>ival;//导致cout的缓冲区被刷新

s.tie();//如果本对象s关联到一个输出流，则返回指向这个流的指针，如果对象未关联到流，返回空指针
s.tie(ostream*);//将自己关联到ostream流
s.tie(&o);//即关联到输出流o
```

## 8.2 文件输入输出

- ifstream从给定文件中读取数据

- ofstream向给定文件写入数据

- fstream读写给定文件

### 8.2.1使用文件流对象

```C++
ifstream in(ifile);//创建ifstream对象时，如果提供了文件名，open自动被调用
ofstream out;//输出文件流未关联到任何文件
```

**用fstream代替iostream&**

```C++
//fstream继承于iostream，如果有一个函数接受iostream&参数，可以用fstream的作为实参传递
//因为fstream继承于iostream，所以fstream的对象也是iostream类型
```

**成员函数open和close**

```C++
//两种打开方式
ifstream in(ifile);//法一
ofstream out;
out.open(ifile);//法二
    
//对一个已经打开的文件流调用open会失败，如果要将文件流关联到另外一个文件，必须用close关闭已经关联的文件
in.close();
```

**自动构造和析构**

```C++
//流离开作用域之后，会自动销毁，close会被自动调用
for()
{
    ifstream input(file);
}
//这里input被自动销毁
```

### 8.2.2 文件模式

```C++
in  //以读的方式打开
out //以写的方式打开
app //每次操作前定位到文件末尾
ate //打开后立即定位到文件末尾
trunc //截断文件，删除部分数据
binary //以二进制方式进行IO
```

- 只可以对ofstream或fstream对象设定out模式
- 只可以对ifstream或fstream对象设定in模式
- 只有当out被设定时才可以设定trunc模式
- 只要trunc没被设定，就可以设定app模式，在app模式下，文件总以out模式打开
- 默认情况下，以out模式打开的文件也会被截断，如果要保留文件的内容，需要同时指定app模式，这样新写入的内容会添加到末尾，或者同时指定in模式
- ate和binary模式适用于任何类型的文件流对象



- ifstream关联的文件默认以in模式打开
- ofstream关联的文件默认以out模式打开
- fstream关联的文件默认以in和out模式打开

**保留ofstream打开的文件中已有数据的唯一方法是显示指定app或in模式**

**调用open时确定文件模式**

```C++
ofstream out;
out.open("file1",ofstream::out | ofstream::app);
```



## 8.3 string 流

<sstream>

- istringstream从string读取数据
- ostringstream向string写入数据 
- stringstream既可从string读数据也可向string写数据

### 8.3.1 使用istringstream

```C++
string line,temp;
istringstream record(line);//将记录绑定到string对象
record>>temp;//读取string对象
//当string中的数据全部读出后，会触发文件结束的信号，写一个输入操作就会失败
```

### 8.3.2使用ostringostream

```C++
string nums;
ostringstream out;
out<<nums;//将string对象输出出来
```

## 8.4 小结

```C++
//普通流iostream
istream, wistream //从流读取数据
ostream, wostream //向流写入数据
iostream, wiostream //读写流
    
 
//文件操作流fstream
ifstream, wifstream //从文件读取数据
ofstream, wofstream //向文件写入数据
fstream, wfstream //读写文件
    
//字符串操作流sstream
istringstream, wistringstream //从string读取数据
ostringstream, wostringstream //向string写入数据
stringstream, wstringstream //读写string
    
//类fstream和stringstream 都是继承自类iostream的。
//输入类都继承自istream,输出类都继承自ostream.
    
//因此，可以在istream对象上执行的操作，也可在ifstream 或istringstream对象上执行。

```



# 9.顺序容器

## 9.1 顺序容器概述

![image-20201219201755476](./Typora_img/image-20201219201755476.png?token=ARTDMQZVHMWKBIC36NG7AG3AQURWS)

forward_list和array是C++11新增内容

支持随机访问的，插入元素的速度就慢

只支持顺序访问的，插入元素的速度就快

**何时使用哪种顺序容器**

- 没有特殊需求，使用vector
- 要求随机访问，使用vector和deque，也可考虑array
- 要求在容器中间插入或删除元素，list或forward_list
- 需要在头和尾插入或删除元素，但不在中间位置插入或删除，使用deque
- 如果必须在中间位置插入元素，考虑在输入阶段使用list，输入完成后，将list中的内容拷贝到vector，然后就可以随机访问了

## 9.2 容器库概览

**容器的类型可以是另一个容器**

```C++
vector<vector<string>> lines;
//有的旧的编译器需要在两个尖括号之间键入空格
vector<vector<string> > lines;
```

**容器的类型可以是类类型**

某些类没有默认构造函数，我们可以定义一个保存这种类型对象的容器，但我们在构造这种容器时不能只传给它一个元素数目

```C++
vector<noDefault> v1(10,init);//正确，提供了元素初始化器
vector<noDefault> v2(10);//错误，必须提供一个元素初始化器
//noDefault没有默认构造函数
```

![image-20210327114052201](./Typora_img/image-20210327114052201.png?token=ARTDMQZQSZ5GON7N64KJORDAQURW4)

![image-20210327114115955](./Typora_img/image-20210327114115955.png?token=ARTDMQ4M6JQUBRPLNBHTOTTAQURW6)

### 9.2.1迭代器

forward_list迭代器不支持递减运算符

**迭代器的范围**

用一对迭代器表示：begin和end   first和last

第二个迭代器不会指向范围中的最后一个元素，**左闭合区间**

[begin,end)

begin和end必须指向相同的容器，begin可以和end指向相同的位置，但end不能指向begin之前的位置

- 如果begin和end相等，范围为空
- 如果begin和end不等，范围至少包含一个元素，且begin指向该范围中的第一个元素

```C++
while(begin!=end)
{
    *begin=val;//赋值
     ++begin;
}
```

### 9.2.2 容器类型成员

使用容器中的类型，必须显式使用其类名

```C++
list<stirng>::iterator iter;//iter是通过list<string>定义的一个迭代器类型
vector<int>::difference_type count;//count是通过vector<int>定义的一个difference_type类型
```

### 9.2.3 begin和end成员

```C++
//begin返回iterator
//rbegin返回reverse_iterator
//cbegin返回const_iterator
//crbegin返回const_reverse_iterator
```

当对一个非常量对象调用rbegin、end和rend时，返回的是iterator，只有对const对象调用这些函数时，返回的才是const_iterator

```C++
//auto经常与begin和end结合使用
auto it1=a.begin();
auto it2=a.cbegin();
//当不需要写访问时，应使用cbegin和cend；
```

### 9.2.4容器定义和初始化

除array之外，每个容器类型都定义了一个默认构造函数

![image-20201219205521179](./Typora_img/image-20201219205521179.png?token=ARTDMQZ67WOA6X4GPDBFKYLAQURXG)

**将一个容器创建为另一个容器的拷贝时，两个容器的类型和其元素类型必须匹配**

当传递迭代器参数来拷贝一个范围时，不要求容器类型相同，新容器和旧容器的元素类型也可以不同，只要能将要拷贝的元素转换为初始化容器的元素类型

```C++
list<string>authors={"Milton","Shake","Austen"};
vector<const char*>articles={"a","an","the"};

list<string> list2(authors);//正确，类型匹配
deque<string> authList(authors);//错误，容器类型不匹配
//authList是deque，authors是list
vector<string> words(articles);//错误，容器类型必须匹配
forward_list<string> words(article.begin(),articles.end());
//正确，可以将const char* 转换为string

//上面：两个迭代器表示一个范围，可以用这种方式拷贝一个容器中的子列
//假定it表示指向author中一个元素的迭代器
deque<string> authList(authors.begin(),it);
```

**列表初始化**

```C++
//对容器列表初始化
list<string> authors={"Milton","Shake","Austen"};
vector<const char*>articles={"a","an","the"};
```

**与顺序容器大小相关的构造函数**

```C++
vector<int> ivec(10,-1);//10个int元素，每个都初始化为-1
list<string> svec(10."hi!");//10个string，每个为hi!
forward_list<int> ivec(10);//10个元素，每个都初始化为0
deque<string> svec(10);//10个元素，每个都是空string
//如果元素类型是类类型且没有默认构造函数，除了大小参数以外，还需要指定一个显式的元素初始值
```

**标准库array**

```C++
//array的大小也是类型的一部分，定义时，必须指定容器大小
array<int,42>;//保存42个int的数组
array<string,10>;//保存10个string的数组
array<int,10>::size_type i;//正确
array<int>::size_type j;//错误，必须指定大小          
```

对array进行列表初始化时，初始值的数量必须等于或小于array的大小，若小于，列表中的值用来初始化array中靠前的元素，剩余的元素会值初始化

**如果元素的类型是类类型，那么该类必须有一个默认构造函数**

```C++
array<int,10> ial;//10个默认初始化的int
array<int,10> ia2={0,1,2,3,4,5,6,7,8,9};
array<int,10> ia3={42}; //ia3[0]为32，剩余元素为0
```

**内置数组不能拷贝或赋值，但array数组可以**

```C++
int digs[3]={0,1,2};
int cpy[3]=digs;//错误，内置数组不支持拷贝或赋值
array<int,3> digits={0,1,2};
array<int,3> copy=digits;//正确，类型匹配即可
```

### 9.2.5赋值和swap

```C++
c1=c2;//将容器c1中的内容替换成c2的元素的拷贝
//即使原来c1与c2两者的大小不同，赋值后c1容器的大小与c2相同
c1={a,b,c};//赋值后,c1的大小为3

//array允许赋值，=两边必须具有相同的类型
array<int,3> a1={0,1,2};
array<int,3> a2={0};//所有元素都为0
a1=a2;//替换a1中的元素
a2={0};//错误，大小不同，赋值和初始化不一样
```

![image-20201219212339891](./Typora_img/image-20201219212339891.png?token=ARTDMQ22U3EORBEUIJ2EDP3AQURXM)

**使用assign**

```C++
//使用assign
list<string> name;
vector<const char*> oldstyle;
names=oldstyle;//错误，容器类型不匹配
names.assgin(oldstyle.cbegin(),oldstyle.cend());
//上面传递给assign的迭代器不能指向调用assign的容器

//assign的第二个版本，接受整型值和元素值，指定数目且具有相同给定值的元素替换容器中原有的元素
list<string> slist1(1);//1个元素，为空string
slits1.assign(10,"Hiya!");//10个元素，每个都是"Hiya!"
```

**使用swap**

```C++
//swap调用后，两个容器中的元素将会交换
vector<string> svec1(10);//10个元素的vector
vector<string> svec2(24);//24个元素的vector
swap(svec1,svec2);//交换后，svec1有24个元素，svec2有10个string

//除array外，交换两个容器的操作很快，因为元素本身并未交换，交换的是容器内部数据结构

//对string调用swap会导致迭代器、引用和指针失效
//其他容器使用swap迭代器、引用和指针不会失效
```

swap两个array会真正交换他们的元素

### 9.2.6 容器大小操作

```C++
s.size();//返回大小
max_size();//返回一个大于或等于该类型容器所能容纳的最大元素数量的值
//forward_list支持max_size和empty，但不支持size	
```

### 9.2.7 关系运算符

除了无序关联容器外的所有容器都支持关系运算符(>、>=、<、<=)。关系运算符左右两边的运算对象必须是相同类型的容器

只能将一个vector<int>与另外一个vector<int>进行比较，不能将vector<int>与一个list<int>或vector<double>进行比较。

- 两个容器具有相同大小且所有元素都两两对应相等，则两个容器相等
- 比较第一个不相等的元素，若元素都相等，则元素少的容器更小


![image-20201219222004255](./Typora_img/image-20201219222004255.png?token=ARTDMQ3UHWJGLYUUMWOMUMLAQURXQ)

**容器的关系运算符使用元素的关系运算符完成比较**

只有当容器的元素类型也定义了相应的比较运算符时，才可以使用关系运算符来比较两个容器，有的类类型没有定义比较运算符，比如Sales_data，那么这样类型的容器就不能用来比较)

```C++
vector<Sales_data> storeA,storeB;
if(storeA<storeB)//错误，Sales_data没有<运算符
```

## 9.3顺序容器操作

### 9.3.1向顺序容器添加元素 

![image-20201220151516660](./Typora_img/image-20201220151516660.png?token=ARTDMQ7ZJU4D3U3DYRXCN7TAQURXY)

**使用push_back**

```C++
string word;
while(cin>>word)
{
    container.push_back(word);
}//在尾部创建新元素，container的size增大了1，该元素的值为word的一个拷贝，container的类型可以是List、vector或deque

//实际放到容器中的是对象值的一个拷贝，而不是对象本身
```

**使用push_front**

```C++
list<int>ilist;
for(size_t ix=0;ix!=4;++ix)
    ilist.push_front(ix);
//插入到ilist逆序插入，比如通过循环插入0,1,2,3,最后的结果是，3,2,1,0
```

**在容器的特定位置添加元素**

```C++
//insert函数接收迭代器为参数，可以指向容器中的任何位置，包括尾部之后的下一个位置。insert将元素插入到迭代器所指定的位置之前
slist.insert(iter,"Hello!");//将"Hello!"添加到iter之前的位置

//通过insert实现push_front的效果
vector<string> svec;
list<string> slist;
slist.insert(slist.begin(),"Hello!");
svec.insert(svec.begin(),"Hello!");//插入到vector末尾之外的任何位置都很慢

//将元素插入到vector、deque和string中任何位置都是可以的，但是会比较慢
```

**插入范围内的元素**

```C++
svec.insert(svec.end(),10,"Anna");//将10个元素插入到svec的末尾，所有元素都是string"Anna"

vector<string> v={"quasi","simba","frollo","scar"};
slist.insert(slist.begin(),v.end()-2,v.end());
//将v的最后两个元素添加到slist的开始位置，包括v.end()-2所指元素，但不包括v.end()所指元素 [ v.end()-2,v.end() )
slist.insert(slist.begin(),{"these","word","will","go"});
//将列表中的值插入到slist开头
//inset返回指向第一个新加入元素的迭代器，以上，如果插入的范围为空，返回第一个参数
slist.insert(slist.begin(),slist.begin(),slist.end());
//迭代器不能指向与目的位置相同的容器
```

**使用insert的返回值**

```C++
//在容器中一个特定位置反复插入元素
list<string>lst;
auto iter=lst.begin();
while(cin>>word)
{
  iter=lst.insert(iter,word); //如果插入的是1234，插入后就是1234
//等价于push_front
}
//iter=lst.insert(lst.begin(),word) //插入1234，实际是4321
```

**使用emplace操作**

调用emplace成员函数时，则是将参数传递给元素类型的构造函数

```C++
vector<Sales_data> c;
c.emplace_back("978-412794",25,15.99);//相当于调用了带三个参数版本的Sales_dat的构造函数，创建了一个临时的Sales_data对象
c.push_back("978-412794",25,15.99);//错误
c.push_back(Sales_data("978-412794",25,15.99));//与第二行语句等价

//第2行与第4行的区别
调用emplace_back时，会在容器管理的内存中直接创建对象，调用push_back时，会创建一个局部临时对象，并将其压入容器中
    
c.emplace_back();//调用Sales_dat的默认构造函数
c.emplace(iter,"999-9999");//使用Sales_data(string)
c.emplace_front("978-3424",25,16.99);
//传递给emplace的参数必须与元素类型的构造函数相匹配
```

### 9.3.2访问元素

```C++
//获取首尾元素
//注意:begin和end返回的是迭代器，front和back返回的是元素
if(!c.empty())
{
    auto val=*c.begin();
    auto val2=c.front();//等价语句
    auto last=c.end();
    auto val3=*(--last);//forward_list迭代器不支持递增操作
    auto val4=c.back();//等价语句，forward_list不支持
}
```

![image-20201220160216284](./Typora_img/image-20201220160216284.png?token=ARTDMQ5TELZIKGTF3FJFVZDAQURYA)

**访问成员函数返回的是引用**

在容器中访问元素的成员函数，如front，back，下标和at返回的都是引用，如果容器是一个const对象，则返回值是const的引用

```C++
//可以当作左值来使用
if(!c.empty())
{
    c.front()=42;//给首元素赋值
    auto &v=c.back();//获得最后一个元素的引用
    v=1024;//改变尾元素的值
    auto v2=c.back();//v2是尾元素的一个拷贝
    v2=0;//未改变C中的元素
}
```

**下标操作和安全的随机访问**

支持快速随机访问的成员都支持下标运算符，

为了确保下标合法，可以使用at成员函数，at成员函数类似于下标运算符，但是下标越界时，at会抛出一个out_of_range异常

```C++
vector<string> svec;//svec为空
cout<<svec[0];//运行时错误，svec中没有元素
cout<<svec.at(0);//抛出一个out_of_range异常
```

### 9.3.3 删除元素

![image-20201220160923085](./Typora_img/image-20201220160923085.png?token=ARTDMQ2LFRQIUMBIBRW2WFTAQURYQ)

**pop_front和pop_back成员函数**

vector和string不支持pop_front和push_front，forward_list不支持pop_back

```C++
while(!ilist.empty())
{
 ilist.pop_front();//删除首元素   
}
```

**从容器内部删除一个元素**

```C++
//erase可以删除指定元素，也可以删除范围元素，返回指向删除的元素之后位置的迭代器。若j是i后面的元素，erase(i)返回指向j的迭代器

//删除奇数
list<int> lst={0,1,2,3,4,5,6,7,8,9};
auto it=lst.begin();
while(it!=lst.end())
{
    if(*it%2)
        it=lst.erase(it);
    else
        ++it;
}
```

**删除多个元素**

```C++
elem1=slist.erase(elem1,elem2);//调用后,elem1==elem2;
//删除两个迭代器表示的范围内的元素[elem1,elem2);
//返回指向最后一个被删元素之后位置的迭代器

//删除所有元素
slist.clear();
slist.erase(slist.begin(),slist.end());//等价语句
```

### 9.3.4特殊的forward_list操作

```C++
before_begin();//返回首前迭代器
```

![image-20201220162604776](./Typora_img/image-20201220162604776.png?token=ARTDMQYOX46YGPWRBKWTQN3AQURYW)

```C++
forward_list<int> flst = {0,1,2,3,4,5,6, 7,8,9};
auto prev = flst.before_begin(); //表示flst的“首前元素”
auto curr = flst.begin(); //表示flst中的第一个元素
while (curr != flst.end())
{
if (*curr %2)//若元素为奇数
curr = flst.erase_after(prev) ; // 删除它并移动curr
else 
{
    prev = curr;//prev始终表示curr前的一个位置  
    ++curr;
}
}
```

### 9.3.5改变容器大小

```C++
list<int> ilist(10,42);// 10个int:每个的值都是42
ilist.resize(15);//将5个值为0的元素添加到ilist的末尾
ilist.resize(25，-1) ;//将10个值为-1的元素添加到ilist的末尾
ilist.resize(5) ;//从ilist末尾删除20个元素
//如果容器保存的是类类型，且resize向容器添加新元素，则我们必须提供初始值，或者元素类型必须提供默认构造函数
```

![image-20201220163104635](./Typora_img/image-20201220163104635.png?token=ARTDMQZBPMU3GS45YXM26V3AQURY4)

### 9.3.6容器操作可能使迭代器失效

**在向容器添加元素后:**
●如果容器是vector或string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。

如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。

●对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效,但指向存在的元素的引用和指针不会失效。

●对于list和forward_list，指向容器的迭代器(包括尾后迭代器和首前迭代
器)、指针和引用仍有效。

**当我们删除元素后:**
●对于list和forward_list,指向容器其他位置的迭代器(包括尾后迭代器和首前迭代器)、引用和指针仍有效。

●对于deque,如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。

如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响;如果是删除首元素，这些也不会受影响。

●对于vector和string, 指向被删元素之前元素的迭代器、引用和指针仍有效。
注意:当我们删除元素时，尾后迭代器总是会失效。

**编写改变容器的循环程序**

```C++
//添加/删除vector、string 或deque元素的循环程序必须考虑迭代器、引用和指针可能失效的问题。
    
//傻瓜循环，删除偶数元素，复制每个奇数元素
vector<int> vi = {0,1,2,3,4,5,6, 7,8,9};
auto iter = vi.begin(); 
while (iter != vi.end()) 
{
if (*iter %2) 
{//是奇数
iter = vi.insert(iter, *iter); //复制当前元素
iter += 2; //向前移动迭代器，跳过当前元素以及插入到它之前的元素
} else
iter = vi.erase(iter) ;//删除偶数元素
//不应向前移动迭代器，iter指向我们删除的元素之后的元素
}

```

**不要保存end返回的迭代器**

因为添加或删除元素后，end返回的迭代器总是会失效，指向的内存空间发生了变化

```C++
auto begin = v.begin();
end = v.end(); //保存尾迭代器的值是一个坏主意
while (begin != end) //此循环的行为是未定义的
{
++begin; 
v.insert(begin，42); // 插入新值
}//死循环，插入新元素之后，end()不再指向v中任何元素

//如果在一个循环中插入/删除deque、string 或vector中的元素，不要缓存end返回的迭代器。

//将第3行改成while(begin!=v.end())即可
```



## 9.4 vector对象是如何增长的

容器会预留空间作为备用，用来保存更多的新元素

![image-20201220173208115](./Typora_img/image-20201220173208115.png?token=ARTDMQZFM3JQA6YYC2OOQTLAQURZG)

reserve并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间。只有当需要的内存空间超过当前容量时，reserve 调用才会改变vector的容量。reserve 至少分配与需求一样大的内存空间(可能更大)。

**capacity和size**

size指已经保存的元素数目，capacity是在不分配新的内存空间的前提下它做多可以保存多少元素

```C++
vector<int> ivec;// size应该为0; capacity的值依赖于具体实现
for (vector<int>::size_type ix = 0; ix != 24; ++ix)
//ivec: size: 0 capacity: 0
    
ivec.push_back(ix);
//ivec:size: 24 capacity: 32

ivec. reserve(50); // 将capacity至少设定为50，可能会更大
//ivec:size: 24 capacity: 50

while (ivec.size() != ivec.capacity())
ivec.push_back(0) ;
//ivec:size: 50 capacity: 50

ivec.push_back(42); //再添加一个元素
//ivec:size: 51 capacity: 100

ivec.shrink_to_fit(); //要求归还内存
//调用shrink_to_fit只是一个请求，标准库并不保证退还内存

//只有当迫不得已时才可以分配新的内存空间。
```

## 9.5 额外的string操作

### 9.5.1 构造string的其他方法

![image-20201220191047280](./Typora_img/image-20201220191047280.png?token=ARTDMQ4ZJQSW4MJ4HIM675DAQURZK)

```C++
const char *cp = "Hello World!!!"; //以空字符结束的数组
char noNull[] = {'H'，'i'};//不是以空字符结束

//string s(s2,pos2,len2)的范围是[pos2,len2),s2的下标从0开始
string s1(cp); //拷贝cp中的字符直到遇到空字符; s1 == "Hello World!! !"
string s2 (noNul1,2);//从noNull拷贝两个字符; s2 == "Hi"
string s3 (noNull);//未定义: noNull不是以空字符结束
string s4(cp+6,5);//从cp[6]开始拷贝5个字符; s4 == "World"
string s5(s1,6,5);// 从s1[6]开始拷贝 5个字符; s5 == "World"
string s6(s1,6);//从s1[6]开始拷贝，直至s1末尾; s6== "World!!!"
string s7(s1,6,20);//正确，只拷贝到s1末尾; s7 == "World!!!"
string s8(s1,16);//抛出一个out_of_range异常

//从一个const char*创建string时，指针指向的数组必须以空字符结
//或者给string的构造函数传递一个计数值，这样数组就不必以空字符结尾

```

**substr操作**

```C++
//substr操作返回一个string，它是原始string的一部分或全部的拷贝。可以传递给substr一个可选的开始位置和计数值:
string s ("hello world") ;
string s2 = s.substr(0, 5) ;// s2 = hello
string s3 = s.substr(6) ;// s3 = world
string s4 = s.substr(6,11) ;// s3 = world [6,11)
string s5 = s.substr(12) ;//抛出一个out_of_range异常
//如果开始位置超过了string的大小，则substr函数抛出一个out_of_range异常
```

![image-20201220191907908](./Typora_img/image-20201220191907908.png?token=ARTDMQ3KMPZ4CNMP57IKPILAQURZS)

### 9.5.2改变string的其他方法

string支持顺序容器的赋值运算符以及assign、insert和erase

```C++
s.insert(s.size(), 5,' !'); // 在s末尾插入5个感叹号
s.erase (s.size()-5, 5); // 从s删除最后5个字符

//可以将以空字符结尾的字符数组通过insert或assign赋给一个string
const char *cp = "Stately, plump Buck";
s.assign(cp,7) ;// s == "Stately"
//assign(cp,7)表示用从cp开始7个字符替换s的内容
s.insert(s.size(),cp + 7);// s == "Stately, plump Buck"
//将cp开始的7个字符，插入到s.[size()]元素之前的位置

//将其他string或字符串插入到当前string
string S = "some string",s2="some other string";
s.insert(0,s2); // 在s中位置0之前插入s2的拷贝
s.insert (0,s2,0,s2.size()) ;//在s[0]之前插入s2中s2[0]开始的s2.size()个字符
```

**append和replace**

```C++
//append是在string末尾插入
string s("C++ Primer"), s2 = s; //将s和s2初始化为"C++ Primer"
s.insert(s.size()，"4th Ed."); // s == "C++ Primer 4th Ed."
s2.append("4th Ed."); // 等价方法:将" 4th Ed. "追加到s2; s == s2 

//replace替换
//将"4th"替换为"5th"
s.erase(11,3) ;// s == "C++ Primer Ed."
s.insert(11,"5th") ;// s== "C++ Primer 5th Ed."
s2.replace(11,3,"5th"); //从位置11开始，删除3个字符并插入"5th"
s.replace(11,3,"Fifth") ; // S=="C++ Primer Fifth Ed.
```

![image-20201220194556050](./Typora_img/image-20201220194556050.png?token=ARTDMQ3MSXPE2TS3C2R3TDTAQURZY)

![image-20201220194613699](./Typora_img/image-20201220194613699.png?token=ARTDMQ5IZ7BZECMFRVTOBO3AQURZ4)

**改变string的多种重载函数**

assign总是替换string中的所有内容,append总是将字符追加到string末尾

添加到string中的字符，新字符可以来自于

- 另一个string，
- 一个字符指针(指向的字符数组)，
- 一个花括号包围的字符列表，
- 一个字符和计数值

### 9.5.3 string搜索操作

string搜索操作返回string::size_type值，是一个unsigned类型

![image-20201220195231865](./Typora_img/image-20201220195231865.png?token=ARTDMQZD3JTTFI32BIMXYDTAQUR2I)

![image-20201220195240218](./Typora_img/image-20201220195240218.png?token=ARTDMQ4PAH3GYVELJPM7QZTAQUR2M)

具体操作示例见P325

### 9.5.4  compare函数

![image-20201220195351587](./Typora_img/image-20201220195351587.png?token=ARTDMQ5BLD4AGOTZQCIL5IDAQUR2S)

### 9.5.5 数值转换

![image-20201220195553916](./Typora_img/image-20201220195553916.png?token=ARTDMQ5NUTNGWXP6XWOC4JLAQUR2W)

```C++
string s2 = "pi = 3.14";
d = stod(s2.substr(s2.find_first_of("+-.0123456789"))) ;
//转换s中以数字开始的第一个子串，结果d = 3.14
```

## 9.6容器适配器

## （建议学了堆栈之后再来看这部分）

三个顺序容器适配器：stack、queue和priority_queue

**简单的理解容器适配器，其就是将不适用的序列式容器（包括 vector、deque 和 list）变得适用即通过封装某个序列式容器，并重新组合该容器中包含的成员函数，使其满足某些特定场景的需要。**

容器适配器本质上还是容器，只不过此容器模板类的实现，利用了大量其它基础容器模板类中已经写好的成员函数。当然，如果必要的话，容器适配器中也可以自创新的成员函数。

![image-20201220200417760](./Typora_img/image-20201220200417760.png?token=ARTDMQ2XDJGW66LGVHXPOFLAQUR24)

![image-20201220200454014](./Typora_img/image-20201220200454014.png?token=ARTDMQ6MRKOAUSZKNMO6OP3AQUR3A)

**定义一个适配器**

每个适配器都有两个构造函数

默认的构造函数创建空对象，接受一个容器的构造函数拷贝该容器来初始化适配器

```C++
//假设deq是一个deque<int>的容器，用dequ来初始化一个新的stack;
stack<int> stk(deq);//从deq拷贝元素到stk

stack<string, vector<string>> str_stk;//在vector上实现的空栈
stack<string, vector<string>> str_stk2 (svec) ;//str_stk2 在vector上实现，初始化时保存svec的拷贝
```

所有的适配器都要求具有添加和删除元素以及访问尾元素的能力

**栈适配器**

![image-20201220201030248](./Typora_img/image-20201220201030248.png?token=ARTDMQ4TQ6JYWLYQ5YJIOTDAQUR3E)

```C++
stack<int> intstack; //空栈.
//填满栈
for (size_ t ix = 0; ix != 10; ++ix)
intstack.push(ix); // intStack 保存0到9十个数
while (!intstack.empty()) 
{ // intStack 中有值就继续循环
int value = intStack.top();
//使用栈顶值的代码
intstack.pop(); // 弹出栈顶元素，继续循环
}
```

**队列适配器**

![image-20201220201133087](./Typora_img/image-20201220201133087.png?token=ARTDMQ4HZ6G2KW7QJSVXQQ3AQUR3G)

![image-20201220201139067](./Typora_img/image-20201220201139067.png?token=ARTDMQ7IN6ZYWJVMFONWIE3AQUR3M)

每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作。我们只可以使用适配器操作，而不能使用底层容器类型的操作。例如，

不能在一个stack上调用push_back,而必须使用stack自己的操作一push。 

# 10.泛型算法

## 10.1 概述

称他们是泛型的，是因为它们可以用于不同类型的元素和多种容器类型 

**标准库算法find**

```C++
auto result=find(vec.cbegin(),vec.cend(),val);
//前两个参数为迭代器，指定一个范围，第三个参数是我们需要查找的值
//返回指向第一个等于给定值的元素的迭代器
//如果无匹配元素，返回第二个参数表示搜索失败

//find可以在数组中查找元素，可以在容器中查找元素
int ia[]={27,210,12,45,105};
int val=83;
int *result=find(begin(ia),end(ia),val);//数组返回的是指针，容器返回的是迭代器

//缩小搜索范围
auto result=find(ia+1,ia+4,val);
//范围[ia+1,ia+4),相当于[ia(1),ia(4))
```

迭代器令算法不依赖于容器，但算法依赖于元素类型的操作。**比如find算法需要==运算符完成每个元素与给定值的比较**，其他算法可能要求元素类型支持<等运算符，这是依赖于元素类型的

**算法永远不会执行容器的操作：算法可能改变容器中保存的元素，也可能在容器内移动元素，但永远不会直接添加或删除元素**



## 10.2 初识泛型算法

 标准库算法一般总是使用前两个参数来表示此范围

### 10.2.1 只读算法

```C++
//accumulate指定范围求和，第三个参数是和的初始值，第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型
int sum=accumulate(vec.cbegin(),vec.cend(),0);
```

**算法和元素类型**

accumulate算法中，序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型。

```C++
string sum=accumulate(v.cbegin(),v.cend(),"");//错误，将空串当作一个字符串字面值传递给第三个参数是不可以的，const char*没有定义+运算符
//第三个参数决定使用哪个+运算符，而const char*没有定义+运算符
```

**equal**

```C++
// roter2中的元素数目应该至少与roster1一样多
equal (roster1.cbegin(),rosterl.cend(),roster2.cbegin());
//equal假定第二个序列至少与第一个序列一样长

//那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。
```

### 10.2.2 写容器元素的算法

一些算法将新值赋予容器中的元素，使用这些算法时，必须确保序列原大小至少不小于我们要求算法写入的元素数目

```C++
fill(vec.begin(),vec.end(),0);//fill将给定的参数赋予输入序列中的每个元素。//这里表示将每个元素重置为0
fill(vec.begin(),vec.begin()+vec.size()/2,10);
```

用一个单一迭代器表示第二个序列的算法都假定第二个序列至少与第一个一样长。

确保算法不会试图访问第二个序列中不存在的元素是程序员的责任。

如果第二个序列是第一个序列的一个子集，则程序会产生一个严重错误一equal 会试图访问第二个序列中末尾之后(不存在)的元素。

**算法不检查写操作**

 ```C++
fill_n(dest,n,val);//从dest的位置开始的n个值，将val的值赋给他们

vector<int> vec; //空vector
fill_n(vec.begin(),vec.size(),0); //将所有元素重置为0

vector<int> vec; //空vector
fill_n(vec.begin(),10,0); //错误，不能向空容器写入值
//算法不添加或删除容器的元素
//向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元素。
 ```

**back_inserter**

back_inserter插入迭代器是一种向容器中添加元素的迭代器。

```C++
//back_inserter 接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。
vector<int> vec; // 空
auto it = back_inserter(vec); // 通过它赋值会将元素添加到vec中
*it = 42; // vec 中现在有一个元素，值为42 //赋值运算符会调用push_back将一个具有给定值的元素添加到容器中

vector<int> vec; //空
//正确: back_inserter创建一个插入迭代器，可用来向vec添加元素
fill_n(back_inserter(vec),10,0); // 添加10个0元素到vec

```

**拷贝算法**

**copy**

```C++
//此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置，将范围中的数拷贝到目的序列中。
//目的序列包含的元素至少要与输入序列一样多

int a1[] = {0,1,2,3,4,5,6, 7,8,9};
int a2[sizeof (al) /sizeof(*a1)]; // a2与al大小一样
//ret指向拷贝到a2的尾元素之后的位置
auto ret = copy (begin(al),end(al),a2); // 把a1的内容拷贝给a2

//copy返回目的位置迭代器尾后的值
```

**replace**

```C++
//将所有值为0的元素改为42
replace(list.begin(),list.end(),0,42);

//使用back_inserter按需要增长目标序列
replace_copy(ilst.cbegin(),ilst.cend(),back_inserter(ivec),0,42); //第三个参数表示调整后序列的保存位置
//此调用后，ilst并未改变，ivec包含ilst的一份拷贝，不过原来在ilst中值为0的元素在ivec中都变为42。
```

### 10.2.3 重排容器元素的算法

**sort**

```C++
//原序列
the quick red fox jumps over the slow red turtle

//sort算法接受两个迭代器，表示要排序的元素范围
sort(words.begin(),words.end());
//排序后fox jumps over quick red red slow the the turtle
```

**unique**

```C++
//unique将相邻的重复项“消除”，返回一个指向不重复值范围末尾的迭代器
auto end_unique=unique(words.begin(),words.end());
```

![image-20201222201247603](./Typora_img/image-20201222201247603.png?token=ARTDMQYS7HMMQENCWX2TWUTAQUR3O)

vector的大小并未改变，它仍有10个元素。unique并不真的删除任何元素，它只是覆盖相邻的重复元素

```C++
//使用向量操作erase删除重复单词
words.erase(end_unique,words.end());//我们删除从end_unique开始直至words末尾的范围内的所有元素。
```

## 10.3 定制操作

### 10.3.1 向算法传递函数

**谓词**

谓词是一个表达式，其返回结果是一个能用作条件的值

**一元谓词：**它们只接受单一参数

**二元谓词：**它们有两个参数

调用的元素类型必须能够转换为谓词的参数类型

```C++
bool isShorter (const string &sl, const string &s2)
{
return s1.size() < s2.size() ;
}

sort (words.begin(), words.end(), isShorter);//第三个参数是一个函数，也是一个二元谓词，它接受两个参数
//？sort是怎么把元素传递给isShorter的形参的
```

**排序算法**

**stable_sort稳定排序算法**

```C++
//stable_sort算法维持相等元素的原有顺序;
//按长度重新排序，长度相同的单词维持字典序
stable_sort(words.begin(),words.end(),isShorter);
//fox red the over slow jumps quick turtle

//原序列
the quick red fox jumps over the slow red turtle
```

### 10.3.2 lambda表达式

**find_if**

find_if接受一对迭代器，表示一个范围，find_if第三个参数是一个谓词，对于输入范围内的每个元素，调用这个谓词，返回一个使谓词非0值的元素。

**lambda：可调用对象**

 除lambda之外，函数和函数指针也是可调用对象，一个lambda表达式表示一个可调用的代码单元

```C++
[capture list](parameter list)->return type {function body}
//lambda表达式，参数列表和返回类型可以省略，捕获列表和函数体不能省略

auto f=[]{return 42;}
f();//调用lambda表达式，与调用函数类似
//如果忽略返回类型，lambda根据函数体中的代码推断出返回类型，

//如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void。
```

**向lambda传递参数**

 向lambda传参与普通函数调用类似，不同的是，lambda不能有默认函参数

```C++
[](const string &a,const string &b) {return a.size()<b.size();}
//空捕获列表表明此lambda不使用它所在函数中的任何局部变量

//使用lambda调用stable_sort;
stable_sort(words.begin(),words.end(),[](const string &a,const string &b){return a.size()<b.size();});
//！！当stable_sort需要比较两个元素时，就会调用这个lambda
```

**使用捕获列表**

一个lambda通过将局部变量包含在其捕获列表中来指出将会使用这些变量。

```C++
void biggies(vector<string> &words,vector<string>::size_type sz)
{
    ...//sz是函数形参，因此是局部变量
    auto wc=find_if(words.begin(),words.end(),[sz](const string &a) {return a.size()>=sz;});
}

[](const string &a){return a.size()>=sz;};//错误，sz未捕获
```

**调用find_if**

```C++
//获取一个迭代器，指向第一个满足size()>= sz的元素
auto wc = find_if(words.begin(),words.end(),[sz] (const string &a) { return a.size()>= sz; } ) ;
```

**for_each算法**

```C++
//打印长度大于等于给定值的单词，每个单词后面接一个空格
for_each (WC，words.end(),[] (const string &s) {cout << s << " ";};
```

一个lambda可以直接使用定义在当前函数之外的名字，比如cout

**完整的biggies**

```C++
void biggies (vector<string> &words,vector<string>::size_type sz)
{
elimDups (words); // 将words按字典序排序，删除重复单词
//按长度排序，长度相同的单词维持字典序
stable_sort(words .begin(), words.end(),[] (const string &a, const string &b) {return a.size()<b.size();)) ;
//获取一个迭代器，指向第一个满足size()>= sz的元素
auto wC = find_if(words.begin(),words.end(),[sz] (const string &a){return a.size()>= sz;}) ;
//计算满足size >= sz的元素的数目
auto count = words.end()-wc;
for_each(wc,words.end(),[] (const string &s) {cout << s <<" ";});
}
```

### 10.3.3 lambda捕获和返回

当定义一个lambda时，编译器生成一个与lambda对应的新的(未命名的)类类型。当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象

**值捕获**

被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝

```C++
void fcn1 ()
{
size_t vl = 42; //局部变量
//将v1拷贝到名为f的可调用对象
auto f = [v1] { return v1; };//f是一个lambda对象
v1=0;
auto j=f();//j为42;f保存了我们创建它时vl的拷贝
}
```

**引用捕获**

```C++
void fcn2 ()
{
size_t v1 = 42; //局部变量
//对象f2包含vl的引用
auto f2 = [&v1] { return vl; };
v1=0;
auto j=f2();//j为0; f2保存v1的引用，而非拷贝
}

//引用捕获有时是必要的，比如IO类不支持拷贝
void biggies (vector<string> &words,vector <string>::size_type sz,ostream &os = cout, char c = ' ')
{
//打印count的语句改为打印到os，前提是该语句之前必须先定义了os和c
for_each(words.begin(),words.end(),[&os, c] (const string &s) { os << s << c; });

//我们也可以从一个函数返回lambda。如果函数返回一个lambda,则与函数不能返回一个局部变量的引用类似，此lambda也不能包含引用捕获。
//当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的。
```

**隐式捕获**

为了指示编译器推断捕获列表，应在捕获列表中写一个&或=。&告诉编译器采用捕获引用方式，=则表示采用值捕获方式。

```C++
// sz为隐式捕获，值捕获方式
wc=find_if(words.begin(),words.end(),[=] (const string &s){return s.size() >= sz;}) ;

//混合使用隐式捕获和显示捕获
void biggies(vector<string> &words,vector<string>::size_type sz, ostream &os=cout,char c=' ')
{
//os隐式捕获，引用捕获方式; c显式捕获，值捕获方式
for_each(words.begin(),words.end(),[&,c] (const string &s) { os << s <<c;});
// os显式捕获，引用捕获方式; c隐式捕获，值捕获方式
for_each (words.begin(),words.end(),[=,&os](conststring&s){ os << s << c;});
}//隐式捕获必须在前
```

**当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&或=。此符号指定了默认捕获方式为引用或值。**

**显式捕获的变量必须使用与隐式捕获不同的方式。**

**即，如果隐式捕获是引用方式(使用了&),则显式捕获命名变量必须采用值方式，因此不能在其名字前使用&。**

**类似的，如果隐式捕获采用的是值方式(使用了=)，则显式捕获命名变量必须采用引用方式，即，在名字前使用&。**

![image-20201222213917300](./Typora_img/image-20201222213917300.png?token=ARTDMQ32FJBIJQ4IPXWUDPDAQUR3U)

**可变lambda**

通过在参数列表后面加上关键字mutable，可以改变被捕获变量的值(不管是值捕获还是引用捕获)

```C++
void fcn3() 
{
size_t v1 = 42; 
auto f = [v1] () mutable { return ++v1; } ;
vl=0;
auto j = f(); //j为43,改变的是从捕获的变量v1拷贝过来的副本值
}

void fcn4()
{
size_t v1 = 42; //局部变量
//v1是一个非const变量的引用,可以通过f2中的引用来改变它
auto f2 = [&v1] { return ++v1; } ;
v1=0;
auto j = f2(); //j为1
}

```

**指定lambda返回类型**

默认情况下，如果一个lambda体包含return之外的任何语句，且没有指定返回类型，则编译器假定此lambda返回void，被推断返回void的lambda不能返回值                                                                                                                                                                                                                                                

```C++
//错误:不能推断lambda的返回类型
transform (vi.begin(),vi.end(),vi.begin(),[] (int i) { if (i < 0) return -i; else return i; });
//推断的返回类型应该是void，但它返回了一个int值
```

当需要为一个lambda定义返回类型时，必须使用尾置返回类型

```C++
transform(vi.begin(),vi.end(),vi.begin(),[] (int i) -> int {if(i<0)return-i;else return i;}); 
//第一个int指的是传递的形参，第二个int是返回值
```

### 10.3.4参数绑定

**标准库函数bind**

```C++
auto newCallable=bind(callable,arg_list);
//当我们调用newCallable时，newCallable会调用callable，并把arg_list中的参数传递给它

//arg_list中可能包含如_1 _2 _3的名字 _n表示占位符
//_1表示传递给newCallable的第一个参数，_2表示传递给newCallable的第二个参数

auto check6 = bind(check_size,_1,6) ;
//_1占位，代替一个string的参数，_1中的1表示这是传递给check6(函数)的第一个参数，_1的位置表示这是check_size函数中的第几个参数

string s="Hi!";
boo1 b1=check6(s);//check6(s)会调用check_size(s,6);
```

**placeholders名字**

名字_n定义在placeholders的命名空间中

```C++
using std::placeholders::_1;
using namespace std::placeholders;
```

**bind参数**

```C++
auto g=bind(f,a,b,_2,c,_1);
//_1 和_2所在的位置表示函数f中对应的参数的位置，
//函数f的第1-5个参数分别为:a,b,_2,c,_1
//_1中的1表示这个参数是函数g中的第一个参数
//_2中的2表示这个参数是函数g中的第二个参数

因此，这个bind会调用g(_1,_2);即调用了函数f(a,b,_2,c,_1);

调用g(X,Y)将会调用f(a,b,Y,c,X)
```

**用bind重排参数顺序**

 ```C++
//按单词长度由短至长排序,相当于调用isShorter(A,B);
sort (words.begin(),words.end(),isShorter);
//按单词长度由长至短排序,相当于调用isShorter(B,A);
sort (words.begin(),words.end(),bind(isShorter,_2,_1));
 ```

**绑定引用参数**

bind中不是占位符的参数，会拷贝到bind返回的函数中，有时参数不是可以拷贝的类型，比如IO类，这时候就需要绑定引用参数

```C++
for_each(words.begin(),words.end(),bind(print,os, _1," "));
//错误，不能拷贝os

for_each(words.begin(),words.end(),bind(print,ref(os), _1," "));
//正确，标准库ref函数返回一个对象，包含给定的引用，此返回的对象是可以拷贝的
//cref函数返回一个对象，包含const引用，定义在头文件functional中
```

旧版C++提供两个bind版本，bind1st和bind2st，

这两个函数接受一个函数作为参数，生成一个可调用对象，该对象调用给定函数，并将绑定的参数给他，但是这两个函数分别只能绑定第一个和第二个参数。

##  10.4再探迭代器

●插入迭代器(insert iterator): 这些迭代器被绑定到一一个容器上，可用来向容器插入元素。
●流迭代器(stream iterator): 这些迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流

●反向迭代器(reverse iterator): 这些迭代器向后而不是向前移动。除forward_ list 之外的标准库容器都有反向迭代器。
●移动迭代器(move iterator):移动容器中的元素

### 10.4.1插入迭代器

通过插入迭代器进行赋值时，该迭代器调用容器操作向容器指定位置插入一元素

![image-20201224105424666](./Typora_img/image-20201224105424666.png?token=ARTDMQ55BKE6BF53T7PDHKDAQUR3Y)

**三种插入迭代器**

●**back_ inserter** 创建一个使用push_ back的迭代器。
●**front_ inserter**  创建一个使用push_ front的迭代器。
●**inserter** 创建一个使用insert的迭代器。此函数接受第二个参数，这个参数是一个指向给定容器的迭代器，表示插入的位置，插入到指定迭代器位置之前

只有在容器支持push_front的情况下,我们才可以使用front_inserter。只有在容器支持push_back的情况下，我们才能使用back_inserter.

```C++
//it是由inserter生成的迭代器，以下两种语句等价
*it=val; //通过赋值插入元素

//等价语句
it=c.insert(it,val);//insert返回指向新元素的指针
++it;//递增it使它指向原来的元素
```

**front_inserter**迭代器

始终插入到容器的第一个元素之前

```C++
list<int> lst={1,2,3,4};
list<int> lst2,lst3; // 空list
//拷贝完成之后，lst2包含4321
copy (lst.cbegin(),lst.cend(),front_inserter(1st2));
//拷贝完成之后，1st3包含1234 //为什么？ 不应该也是4321吗
copy (lst.cbegin(),lst.cend(),inserter(1st3,1st3.begin()));
//inserter(1st3,1st3.begin())??是什么意思
```

### 10.4.2 iostream迭代器

可以作用于IO类的迭代器，这些迭代器把对应的流当作一个序列来处理，好处是可以通过泛型算法对流对象进行一些读写操作

**istream_iterator迭代器读取输入流，ostream_iterator迭代器输出流写数据**



**istream_iterator操作**

```C++
//创建istream_iterator时绑定到流
//如果不绑定，默认初始化，则创建了一个可以当作尾后值使用的迭代器
//创建
istream_iterator<int> int_it(cin) ;// 从cin读取int
istream_iterator<int> int_eof; //尾后迭代器
ifstream in("afile");
istream_iterator<string> str_it(in); // 从"afile"读取字符串

//读数据
istream_iterator<int> in_iter(cin); // 从cin读取int
istream_iterator<int> eof; // istream尾后迭代器
while (in_iter != eof)
vec.push_back(*in_iter++) ;//++运算符和*运算符对流迭代器不起作用

//vec构造函数从cin中读取数据，直到文件尾或遇到一个不是int的数
istream iterator<int> in_iter(cin),eof; // eof是尾后迭代器
vector<int> vec(in_iter, eof); //从迭代器范围构造vec

```

![image-20201224113702177](./Typora_img/image-20201224113702177.png?token=ARTDMQ7HRAIUONR4VVK2HMLAQUR34)

**使用算法操作流迭代器**

```C++
istream iterator<int> in(cin),eof;
cout << accumulate (in,eof,0) << endl;
//对流中对象求和
```

**istream_iterator允许使用懒惰求值**





**ostream_iterator操作**

必须将ostream_iterator绑定到一个指定的流，不允许空的或表示尾后位置的ostream_iterator，如果有第二个参数(字符串)，此字符串必须是一个C风格字符串

![image-20201224133341524](./Typora_img/image-20201224133341524.png?token=ARTDMQ4PXLWJWYWA434NBODAQUR4C)

```C++
//用ostream_iterator输出值的序列
ostream_iterator<int> out_inter(cout," ");
for(auto e:vec)
    *out_iter++=e; //赋值语句相当于将元素写入cout，也就相当于cout<<操作

//等价写法
out_iter=e;//*和++对ostream_iterator对象不做任何事，可以理解为out_iter会自己动

//通过调用copy来打印vec中的元素
copy(vec.begin(),vec.end(),out_iter);
```

**使用流迭代器处理类类型**

只要定义了<<和>>运算符的类型，就可以创建ostream_iterator迭代器和istream_iterator迭代器，但是对于自定义类型的比如Sales_item，需要定义了<<和>>运算符才能使用这两个迭代器

```C++
istream_iterator<Sales_item> item_iter (cin),eof;
ostream_iterator<Sales_item> out_iter (cout，"\n") ;
//将第一笔交易记录存在sum中，并读取下一条记录
Sales_item sum = *item_iter++;//将第一条交易记录保存在sum中，并读取下一条记录
while (item iter != eof) 
{//如果当前交易记录(存在item_ iter中)有着相同的ISBN号
if (item_iter->isbn() == sum. isbn())
sum += *item_iter++;// 将其加到sum上并读取下一条记录  。++不起作用，item_iter自动移动
else 
{
out_iter = sum;//输出sum当前值 
sum = *item_iter++;//读取下一条记录
}
out_iter = sum;//记得打印最后一 组记录的和
```



### 10.4.3反向迭代器

除了forward_list之外，其他容器都支持反向迭代器

![image-20201224135744197](./Typora_img/image-20201224135744197.png?token=ARTDMQ2KCATOBXZHPTD7W7LAQUR4E)

```C++
//使用反向迭代器逆序打印vector中的元素
vector<int> vec = {0,1,2,3,4,5,6,7,8,9};
for (auto r_iter = vec.crbegin();r_iter!= vec.crend();++r_iter)//从尾元素到首元素的反向迭代器//
cout << *r_iter << endl;//打印9，8，7，...0

//sort逆向排序
sort(vec.begin(),vec.end()); //按“正常序”排序vec
sort(vec.rbegin(),vec.rend()) ;//按逆序排序:将最小元素放在vec的末尾

```

**反向迭代器和其他迭代器间的关系**

```C++
auto comma = find (line.cbegin(), line.cend(), ',');
//如果line中有逗号，那么comma将指向这个逗号，否则返回line.cend()
cout << string(line.cbegin(),comma) << endl;
//打印line.cbegin()到comma之间的内容

auto rcomma = find (line.crbegin(),line.crend(), ',');
//find找到最后一个逗号并返回迭代器，否则返回line.crend()
cout << string(line.crbegin(),comma) << endl;
//这里会逆序打印，比如输入FIRST,MIDDLE,LAST则输出 TSAL

//通过调用reverse_iterator的base函数将rcomma转换为一个普通迭代器

cout << string (rcomma.base(),line.cend()) << endl;
//正确:得到一个正向迭代器，从逗号开始读取字符直到line末尾
```

![image-20201224140836842](./Typora_img/image-20201224140836842.png?token=ARTDMQ74AFO77NJMF7PYHZDAQUR4I)

[line.crbegin()，rcomma）和 [rcomma.base(),line.cend())指向line中相同位置元素，所以rcomma和rcomma.base()必须指向相邻位置

**当我们从一个普通迭代器初始化一个反向迭代器，或是给一个反向迭代器赋值时，结果迭代器与原迭代器指向的并不是相同的元素，而是相邻的元素**



## 10.5 泛型算法结构

算法所要求的迭代器操作可以分为5个迭代器类别

![image-20201224141124219](./Typora_img/image-20201224141124219.png?token=ARTDMQ5SNHGSXBJCVL3CWUDAQUR4M)

### 10.5.1   5类迭代器

**输入迭代器** <<

输入迭代器只用于顺序访问，递增输入迭代器可能导致其他指向流的迭代器失效。输入迭代器必须支持

●用于比较两个迭代器的相等和不相等运算符(==、 !=)
●用于推进迭代器的前置和后置递增运算(++)
●用于读取元素的解引用运算符*; 解引用只会出现在赋值运算符的右侧
●箭头运算符(->)， 等价于( *it) . member, 即，解引用迭代器，并提取对象的成员



**输出迭代器** >>

输出迭代器支持

●用于推进迭代器的前置和后置递增运算(++)
●解引用运算符(*)， 只出现在赋值运算符的左侧(向一个已经解引用的输出迭代器赋值，就是将值写入它所指向的元素)

**前向迭代器**

前向迭代器只能在序列中沿一个方向移动,forward_list上的迭代器是前向迭代器

**双向迭代器**

**随机访问迭代器**

随机访问迭代器支持

●用于比较两个迭代器相对位置的关系运算符(<、<=、>和>=)
●迭代器和一个整数值的加减运算(+、+=、-和-=)，计算结果是迭代器在序列中前进(或后退)给定整数个元素后的位置
●用于两个迭代器上的减法运算符(-)， 得到两个迭代器的距离
●下标运算符(iter[n])， 与* (iter[n])等价

### 10.5.2 算法形参模式

大多算法具有如下4种形式之一

```C++
alg(beg, end, other args) ;
alg(beg，end， dest, other args) ; 
alg(beg, end, beg2， other args) ; 
alg(beg，end, beg2, end2， other args) ;
//alg是算法的名字，beg和end表示操作的范围
```

**接受单个目标迭代器的算法**

向输出迭代器写入数据的算法都假定目标空间足够客纳写入的数据。

**接受第二个输入序列的算法**

接受单独beg2的算法假定从beg2开始的序列与beg和end所表示的范围
至少一样大。

接受单独beg2和end2的算法假定从beg2开始到end2的序列与beg和end所表示的范围至少一样大。

### 10.5.3算法命名规范

**一些算法使用重载形式传递一个谓词**

```C++
//接受谓词参数来替代<或==运算符
unique(beg,end);//使用==运算符比较元素
unique(beg,end,comp);//使用谓词comp比较元素
```

**_if版本的算法**

```C++
//if版本通常是接受一个元素值的算法的另一版本，不是重载
find(beg, end, val) ;//查找输入范围中val第一次出现的位置
find_if(beg, end, pred) ;//查找第一个令pred为真的元素,pred是谓词
```

**区分拷贝元素的版本和不拷贝的版本**

默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。
另一个版本，将元素写到一个指定的输出目的位置。这种算法的名字后面都有一个_copy

```C++
reverse(beg, end) ;//反转输入范围中元素的顺序
reverse_copy(beg, end, dest) ;//将元素按逆序拷贝到dest

//同时提供_copy和_if版本
//从v1中删除奇数元素
remove_if(v1.begin(),v1.end(),[](inti){return i % 2;});
//将偶数元素从vl拷贝到v2; v1不变
remove_copy_if(v1.begin(),v1.end(),back_inserter(v2),[](inti){return i % 2;});
```

## 10.6特定容器算法

对于list和forward_list, 这两个是链表类型，应该优先使用成员函数版本的算法而不是通用算法。

一个链表可以通过改变元素间的链接而不是真的交换它们的值来快速“交换元素”

![image-20201224143212678](./Typora_img/image-20201224143212678.png?token=ARTDMQYUHY2PBSYWTSXERBTAQUR4Q)

![image-20201224143218284](./Typora_img/image-20201224143218284.png?token=ARTDMQ3WGCWOWMQK3I6VQ4DAQUR4S)

**splice成员** 链表数据结构所特有

![image-20201224143507669](./Typora_img/image-20201224143507669.png?token=ARTDMQ7OFTXQH2U5TXKJDYLAQUR4W)

链表特有的操作会改变容器，比如删除元素，改变大小

