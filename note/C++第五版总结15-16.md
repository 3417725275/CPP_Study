# 15.面向对象程序设计

通过使用数据抽象，可以将类的接口与实现分离

## 15.1 OOP：概述

派生类必须通过使用类派生列表明确指出它是从哪个类继承而来的。

```C++
class
Bulk_quote:public Quote{}
//Bulk_quote继承于Quote
```

因为派生是public权限，所以可以把Bulk_quote的对象当作Quote的对象来使用

**虚函数**

```C++
class Quote {
public:
std::string isbn() const;
virtual double net_price (std::size_t n) const;
};

class Bulk_quote:public Quote 
{
//Bulk_quote继承了Quote
public:
double net_price(std::size_t) const override;
};
//C++11，在函数形参列表后增加一个override显示地注明将使用哪个成员函数改写基类的虚函数
```

**动态绑定**

通过使用动态绑定,我们能用同一段代码分别处理Quote和Bulk_quote的对象。

```C++
//计算并打印销售给定数量的某种书籍所得的费用
double print_total (ostream &os, const Quote &item, size_t n)
{
//根据传入item形参的对象类型调用Quote::net_price或者Bulk_quote::net_price
double ret = item.net_price(n) ;
os << "ISBN: ”<< item.isbn()
//调用Quote::isbn
return ret;
}


// basic的类型是Quote; bulk的类型是Bulk_quote
//Bulk_quote继承于Quote
print_total (cout, basic, 20) ;
//调用Quote的net_price

print_total (cout, bulk, 20) ;
//调用Bulk_quote的net_price


//调用的net_price版本由实参版本决定，在函数运行时选择函数的版本，所以动态绑定又称运行时绑定
```

**当我们使用基类的引用(或指针)调用一个虚函数时将发生动态绑定。**

根据引用或指针所绑定的对象类型不同，可能执行基类版本也可能执行派生类版本

## 15.2 定义基类和派生类

### 15.2.1 定义基类

```C++
class Quote {
public:

virtual double net_price(std::size_t n) const
{ return n * price; }
virtual ~Quote() = default; // 基类通常定义一个虚析构函数，即使函数不执行任何实际操作也是如此
private:
std::string bookNo;//书籍的ISBN编号
protected:
double price = 0.0;//代表普通状态下不打折的价格
};

```

**基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。**



**成员函数与继承**

- 任何构造函数之外的非静态函数都可以是虚函数
- 关键字virtual只能出现在类内部函数声明之前，不能用于类外部的函数定义
- 如果基类中一个函数被声明成虚函数，则派生类中隐式地也是虚函数



**访问控制与继承**

派生类能够访问基类的public和protect成员，但不能访问基类的private成员

?派生类不是会继承基类的成员吗，他自己不是就有了对应的数据成员，为什么还要访问基类的数据成员



### 15.2.2 定义派生类

派生类必须将其继承而来的成员函数中需要覆盖（重写）的那些重新声明，因此Bulk_quote类必须包含一个net_price成员

```C++
class Bulk_ quote : public Quote {
//Bulk_quote 继承自Quote
public:
Bulk_quote() = default;
Bulk_quote(const std::string&，double，std::size_t，double) ;
//覆盖基类的net_price函数版本以实现基于大量购买的折扣政策
double net_price(std::size_t) const override;
private:
std::size_t min_qty = 0;
double discount = 0.0;
//以小数表示的折扣额
};

```

如果一个派生是public派生的，则基类的公有成员也是派生类接口的组成部分。我们能将公有派生类型的对象绑定到基类的引用或指针上。

//protected派生和private派生是否可以

Bulk_ quote 的接口隐式地包含isbn 函数(继承于基类)，

同时在任何需要Quote的引用或指针的地方我们都能使用Bulk_ quote 的对象。(把派生类对象当作基类对象使用，因为Bulk_quote继承于Quote，所以Bulk_quote的对象也是Quote类型的，可以把Bulk_quote的对象传给Quote类型的形参)

**前提是必须是引用或指针形参**



**派生类中的虚函数**

如果派生类没有重写基类的虚函数，则默认继承基类的虚函数



**派生类对象及派生类向基类的类型转换**

 一个Bulk_ quote 对象将包含四个数据元素:它从Quote继承而来的bookNo和price数据成员，以及Bulk quote 自己定义的min_qty 和discount成员。

![image-20201231215019548](./Typora_img\image-20201231215019548.png)

在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的。

因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，**也能将基类的指针或引用绑定到派生类对象中的基类部分上。**

```C++
//Bulk_quote继承于Quote
Quote item;//基类对象
Bulk_quote bulk;//派生类对象
Quote *p = &item; //p指向Quote对象
P = &bulk;//p指向bulk(派生类对象)中属于Quote(基类)部分
Quote &r = bulk;//r绑定到bulk的Quote部分

```



**派生类构造函数**

每个类控制它自己的成员初始化过程：派生类从基类继承过来的成员，必须使用基类的构造函数来初始化它。

(理解：这里是不是可以看作，继承数据成员的时候，并不是拷贝一份数据成员，而是共享的形式，所以初始化继承过来的成员还是要用基类的构造函数？待验证)

初始化成员的过程：派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数的。继承过来的成员用基类的构造函数初始化

```C++
Bulk_quote (const std::string& book,double P,std::size_t qty， double disc):Quote(book,p),min_qty(qty),discount (disc) { }
//该函数将它的前两个参数(分别表示ISBN和价格)传递给Quote的构造函数,由Quote的构造函数负责初始化Bulk_quote的基类部分(即bookNo成员和price成员)。接下来初始化由派生类直接定义的min_qty 成员和discount成员。最后运行Bulk_quote构造函数的函数体。

//如果上面没有显式调用Quote(book,p)构造函数，那么派生类对象的基类部分会像数据成员一样执行默认初始化
```

**派生类使用基类的成员**

派生类可以访问基类的公有成员和受保护成员

派生类的作用域嵌套在基类的作用域之内

派生类对象不能直接初始化基类的成员。应该通过调用基类的构造函数来初始化那些从基类中继承而来的成员

**继承与静态成员**

如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义

假如某静态成员是可访问的(public)，我们既能通过基类使用它也能通过派生类使用它

```C++
class Base 
{
public:
static void statmem() ;
};
//继承
class Derived : public Base
{
void f (const Derived&) ;
};
//调用静态成员
void Derived::f (const Derived &derived_obj)
{
Base::statmem();//正确: Base定义了statmem
Derived::statmem() ;//正确: Derived继承了statmem
//正确:派生类的对象能访问基类的静态成员
derived_obj.statmem() ;//通过Derived对象访问
statmem();//通过this对象访问
}

```

**派生类的声明**

```C++
class Bulk_quote:public Quote; 
// 错误:派生列表不能出现在这里(:后面部分)
class Bulk_quote;
//正确:声明派生类的正确方式
```

**被用作基类的类**

```C++
//如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明:
class Quote;//声明但未定义,错误: Quote必须被定义
class Bulk quote : public Quote { ... };

```

一个类不能派生它本身

一个类可以是基类，同时也可以是一个派生类

```C++
class Base { /* ... */ };
class D1: public Base { /* ...*/ };
class D2: public D1 { /* ...*/ };
//在这个继承关系中，Base是D1的直接基类,同时是D2的间接基类

```

最终的派生类将包含它的直接基类的成员及每个间接基类的成员

**防止继承发生**

有时我们会定义这样一种类，我们不希望它作基类，C++11新标准提供了一种防止继承发生的方法，在类名后跟一个关键字final:

```C++
class NoDerived final { /* */ };
//NoDerived 不能作为基类
class Base { /* */ };


class Last final : Base { /* */ };// Last 不能作为基类
class Bad : NoDerived { /* */ };//错误: NoDerived是final的
class Bad2 : Last { /* */ };//错误:Last是final的.

```

### 15.2.3 类型转换与继承

我们可以将基类的指针或引用绑定到派生类对象上，（实际绑定的是派生类对象中基类的部分上）,也可以把一个派生类对象的地址赋给基类的指针

例如，我们可以用Quote&指向一个Bulk_quote对象，也可以把一个Bulk_ quote 对象的地址赋给一个Quote*

存在的问题：当使用基类的引用或指针时，实际上并不清楚该引用所绑定的对象是基类还是派生类型

智能指针类也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内。



**静态类型与动态类型**

**静态类型**：变量或表达式的类型，编译时已知，

**动态类型**：变量或表达式所表示的内存中的对象的类型，运行时可知



```C++
double print_total (ostream &os,const Quote &item, size_t n)
{
double ret = item.net_price(n) ;
return ret;
}
//print_total调用net_price时
//item的静态类型时Quote，因为形参是这个类型，而动态类型依赖于iteme绑定的实参，直到运行时调该函数才知道，它真实绑定的是Quote类型还是Bulk_quote类型
```

**如果表达式既不是引用也不是指针，则静态类型与动态类型永远一致**

比如上面的函数形参变为Quote item而不是Quote &item，则传入的实参永远是一个Quote对象

(这里是否意味着不能传入Bulk_quote对象，还是传入Bulk_quote对象后，会隐式转换成Quote类型)



**不存在从基类向派生类的隐式转换**

基类对象可以是派生类对象的一部分？？如何理解

(我的理解：派生类实例化对象的时候，从基类继承过来的那部分数据成员，可以理解成基类的对象)

**基类指针可以指向派生对象，即指向派生类对象中属于基类的部分，但是，派生类指针不能指向基类对象**

```c++
Quote base;
Bulk_quote* bulkP = &base;//错误:不能将基类转换成派生类
Bulk_quote& bulkRef = base;//错误:不能将基类转换成派生类

//如果赋值合法，可能会使用派生类对象访问基类对象中本不存在的内容(派生类独有的部分)
```

```C++
//即使一个基类指针或引用绑定在一个派生类对象上,我们也不能执行从基类向派生类的转换
Bulk_quote bulk;
Quote *itemP = &bulk;//正确:动态类型是Bulk_quote 
Bulk_quote *bulkP = itemP;//错误:不能将基类转换成派生类

```

编译器只检查指针或引用的静态类型

可以使用static_cast将基类强制转换成派生类，前提是该转换是正确的



**对象之间不存在类型转换**

派生类向基类的自动类型转换只对指针或引用类型有效。

```C++
Bulk_quote bulk;//派生类对象
Quote item(bulk) ;
//使用Quote::Quote (const Quote&) 构造函数
item = bulk;
//调用Quote::operator=(const Quote&)

//第2行和第4行的操作，该函数只能将bulk中的Quote部分成员进行赋值，同时忽略掉bulk中Bulk_quote部分成员(派生类独有成员)

//bulk的Bulk_quote部分被切掉了
```

**当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。**

- 从派生类向基类的类型转换只对指针或引用类型有效。
- 基类向派生类不存在隐式类型转换。
- 派生类向基类的类型转换也可能会由于访问受限而变得不可行。只有public派生才能动态绑定
- 通常能够将一个派生类对象拷贝移动赋值给基类对象，但是这种操作只能处理派生类对象的基类部分(赋值后基类对象不包含派生类独有的数据成员)



## 15.3 虚函数

每一个虚函数都必须定义，不管是否使用它

这是因为编译器也无法确定到底会使用哪个虚函数？(这话怎么理解)

(一般函数，如果不使用它，可以只有声明)



**对虚函数的调用可能在运行时才被解析**

通过指针或引用调用虚函数时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与能与动态类型相匹配的对象的虚函数。

```C++
//函数print_total中存在item.net_price(n)
//net_price是虚函数
//调用什么版本取决于运行时实际的动态类型

Quote base("0-201-82470-1"，50) ;
print_total (cout, base, 10) ; //调用Quote::net_price
Bulk_quote derived("0-201-82470-1",50,5,19);
print_total (cout,derived,10);//调用Bulk_quote::net_price
```

动态绑定只有当我们通过指针或引用调用虚函数时才会发生(引用或指针是虚函数的形参，通过指针或引用调用虚函数)

```C++
base = derived; //把derived的Quote部分拷贝给base
base.net_price(20) ;//调用Quote::net_price
//base是Quote类型，既不是引用也不是指针，这里属于通过对象调用，对象的类型是确定的，不发生动态绑定，此时调用什么版本的net_price在编译时就会确定
```

当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。

**派生类的作用域嵌套在基类的作用域中，可以从这个地方去理解静态和动态绑定**



**派生类中的虚函数**

派生类中的虚函数virtual关键字可加可不加，因为虚函数继承后必为虚函数(一般为了清晰，都会加上)

派生类从基类中继承来的虚函数，形参类型、返回类型必须与所继承的虚函数一致，



有一个例外：**当虚函数返回类型是类本身的指针或引用时，可以不用一致，基类B的虚函数返回B*，**

**则派生类D的虚函数可以返回D*, 前提是，D:public B，可访问继承**





**final与overide说明符**

如果派生类中的虚函数和基类中形参类型不一致，则派生类中的这个虚函数是与基类中的所继承的虚函数相互独立，基类中的虚函数没有被覆盖

overide:使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错。

```C++
struct B 
{
virtual void f1 (int) const;
virtual void f2() ;
void f3() ;
};
struct D1:B
{
void f1 (int) const override; //正确:f1与基类中的f1匹配
void f2 (int) override;//错误: B没有形如f2(int)的函数
void f3() override;//错误:f3不是虚函数
void f4() override;//错误: B没有名为f4的函数
};

```

如果我们把某个函数定义成final，则之后任何尝试覆盖该函数的操作都是错误的

```C++
struct D2:B
{
//从B继承f2()和f3(),覆盖fl(int)
void f1 (int) const final; //不允许后续的其他类覆盖f1 (int)
};
struct D3 : D2{
void f2 () ;// 正确: 覆盖从间接基类 B继承而来的f2.
void f1 (int) const;//错误: D2已经将f2声明成final .
};

```

final和overide说明符出现在形参列表，包括const修饰符，包括尾置返回类型之后。



**虚函数与默认参数**

如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。

如果某次函数使用了默认实参，则该实参是多少由本次调用的静态类型决定

换句话说，

如果一个虚函数有默认实参

基类指针指向基类对象，那么调用没问题

基类指针指向派生类对象，这时候调用，会调用派生类重写的虚函数版本，但是派生类重写的那个虚函数中的默认实参 ，是由基类版本的默认实参传递过来的



**回避虚函数的机制**

通过作用域运算符可以避免动态绑定机制

```C++
//强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么
double undiscounted = baseP->Quote::net_price(42);
```

通常情况下，只有成员函数(或友元)中的代码才需要使用作用域运算符来回避虚函数的机制。

(如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用（动态类型为派生类型），从而导致无限递归??**为什么会出现无限递归**)



## 15.4抽象基类

**纯虚函数**

纯虚函数无须定义（可以定义也可以不定义），在函数语句声明之后加上=0可以将一个虚函数声明称纯虚函数

（虚函数无论是否使用都必须定义）

```C++
//用于保存折扣值和购买量的类，派生类使用这些数据可以实现不同的价格策略
class Disc_quote : public Quote 
{
public:

double net_ price(std: :size_t) const = 0;

};

```

含有纯虚函数 的类是抽象基类，我们不能定义抽象基类的对象，但是会调用抽象基类的构造函数来构建各个派生类对象的(基类)Disc_quote部分

不能在类的内部为一个=0的函数提供函数体，但是可以在体外给纯虚函数提供定义

抽象基类负责定义接口，而后续的其他类可以覆盖该接口。因为Disc_ _quote 将net_ price定义成了纯虚函数，所以我们不能定义Disc_ quote的对象。我们可以定义Disc_quote 的派生类的对象，前提是这些类覆盖(重写)了net_ price 函数:

```C++
// Disc_quote声明了纯虛函数，而Bulk_ quote中必须覆盖该函数才能定义对象
Disc_quote discounted;//错误:不能定义Disc_quote的对象
Bulk_quote bulk;//正确: Bulk_quote中没有纯虚函数

```

**Disc_quote的派生类必须给出基类中纯虚函数的定义，否则派生类仍将是抽象基类**



**派生类构造函数只初始化它的直接基类**

例如A:B:C， A的构造函数会委托B的构造函数，B的构造函数会委托C的构造函数

(直接基类，class Bulk_quote : public Disc_quote，则Disc_quote是Bulk_quote的直接基类，而Disc_quote:Quote，Quote是Bulk_quote的间接基类)

每个Bulk_ quote对象包含三个子对象:一个(空的) Bulk_ quote 部分、一个Disc_ quote子对象和一个Quote子对象。

Bulk_quote 构造函数调用顺序：

- 先调用Quote的构造函数
- 再调用Disc_quote的构造函数
- 再调用Bulk_quote的构造函数



## 15.5 访问控制与继承



派生类的成员和友元可以访问基类中的Public和protected成员

派生类的成员和友元函数只能访问**基类中的protected成员**

```C++
class Base 
{
protected:
int prot_ mem;
// protected成员
};

class Sneaky : public Base {
friend void clobber (Sneaky&) ;//能访问Sneaky::prot_mem(继承而来的成员)
friend void clobber (Base&) ;//不能访问Base::prot_mem
int j;// j默认是private ;
};
//正确: clobber能访问Sneaky对象的private和protected成员
void clobber (Sneaky &s) { s.j = s.prot_mem = 0; }
//错误: clobber不能访问Base的protected成员
void clobber (Base &b) { b.prot_mem = 0; }

```



**公有、私有和受保护继承**

派生访问说明符的目的是控制派生类用户(包括派生类的派生类在内)对于基类成员的访问权限:

```C++
class Base 
{
public:
void pub_mem(); 
protected:
int prot_mem;
private:
char priv_ mem;
};

struct Pub_Derv : public Base 
{
int f() { return prot_ mem; }//正确:派生类能访问protected成员
char g() { return priv_ mem; }//错误: private成员对于派生类来说是不可访问的
};

struct Priv_Derv : private Base
{
// private继承不影响派生类的访问权限
int f1()const { return prot_ mem; } //正确
};


Pub_Derv d1 ; //继承自Base的成员是public的
Priv_Derv d2; //继承自Base的成员是private的
d1.pub_mem() ; //正确:pub_mem在派生类中是public的.
d2.pub_mem() ; //错误: pub_mem在派生类中是private的
```

派生访问说明符：简单的说，

- 假如是private继承，那么从基类继承过来的数据成员就会变成private的，
- 假如是protected继承，那么从基类继承过来的数据成员就会变成protected的，
- 如果继承是public，继承过来的成员维持其原有的访问说明符，原来是private继承后就是private

**这个访问说明符号主要是对派生类的对象的访问权限起作用**



**派生类向基类转换的可访问性**

假定D继承自B

●只有当D公有地继承B时，用户代码才能使用派生类向基类的转换;如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换。
●不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换:派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。
●如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换;反之，如果D继承B的方式是私有的，则不能使用。



```C++
//针对上面小结，参考习题15.18-15.20
1.只有派生类公有的继承基类时，才能使用派生类向基类的转换,protected和private则不行
例如: Base* p=new Pub_Derv d1;
//这里说的转换，指的是可以让一个基类的指针指向派生类的对象
2.无论派生类如何继承于直接基类，在派生类的成员函数和友元函数中，都可以把本类对象(派生类对象)，即*this赋值给基类指针(引用)
例如在派生类成员函数中，可以
    Base &b=*this;
//这里的转换只针对于直接基类和派生类之间
3.对于间接基类和派生类之间，例如DD:D:Base,Base是DD的间接基类
只有当DD是public或protected继承于D类的时候，在DD的成员函数或友元函数中，才可以把本类对象(DD类)赋值给间接基类
例如；在DD类的成员函数中，可以
    Base &b=*this
//如果DD是private继承于D，就不能把DD转换给Base了
```







**友元与继承**

基类的友元函数不能访问派生类的成员，同样的，派生类的友元函数也不能访问基类的成员

```C++
class Base 
{
friend class Pal ;
// Pal 在访问Base的派生类时不具有特殊性
};

class Pal 
{
public:
int f(Base b) { return b.prot_ mem; } // 正确: Pal是Base的友元,可以访问b(Base对象)的protected成员
int f2(Sneaky s){ return s.j; } // 错误: Pal不是Sneaky的友元
    
//prot_men是protected成员
int f3(Sneaky s) { return s.prot_ mem; } // 正确: Pal是Base的友元，s继承于基类Base，可以通过Pal访问s中继承于基类的部分，虽然说是从Base中继承过来的，但是这些数据成员可以理解成Base的对象
};

```

**不能继承友元关系**

```C++
class D2 : public Pal {
public:
int mem(Base b)
{ return b.prot_ mem; }
//D2继承于Pal，Pal是Base的友元，D2对于Base没有特殊访问权限
};

```

**改变个别成员的可访问性**

通过using关键字改变派生类继承的某个名字的访问级别

```C++
class Base
{
public:
std::size_t size() const { return n;}
protected:
std::size_t n;
};

class Derived:private Base {
// 注意: private继承
public:
using Base::size;
protected:
using Base::n;
};

//因为Derived是private继承，所以继承来的成员size和n都是private成员，通过using语句声明改变这些成员的可访问性
Derived对象可以访问Base::size,Derived的派生类可以访问Base::size和Base::n
    
//如果using语句出现在private下面，那么继承过来的成员仍然是私有的，只有本类的成员函数和友元函数可以访问


```

**默认的继承保护级别**

class和struct唯一的差别就是默认成员访问说明符和默认派生访问说明符

默认情况下，使用class关键字定义的派生类是私有继承的;而使用struct关键字定义的派生类是公有继承的:

```C++
class Base { /* ...*/ };
structD1:Base{/*...*/};//默认public继承
classD2:Base{/*...*/};//默认private继承

```

**建议把默认的设置显示的表示出来，这样比较清晰**



## 15.6 继承中的类作用域

派生类的作用域嵌套在基类中，如果一个名字在派生类的作用域内无法正确解析，编译器会继续在外层的作用域内寻找该名字的定义



**在编译时进行名字查找**

我们能使用哪些成员仍然是由静态类型决定的

```C++
class Disc_quote : public Quote {
public:
std::pair<size_t, double> discount_policy() const
{ return {quantity, discount}; }

};

//我们只能通过Disc_quote及其派生类的对象、引用或指针使用discount_policy:
Bulk_quote bulk;
Bulk_quote *bulkP = &bulk;
//Bulk_quote是Disc_quote的派生类
//静态类型与动态类型一致

Quote *itemP = &bulk;
//静态类型与动态类型不一致.
bulkP->discount_policy() ;
//正确: bulkP的类型是Bulk_ quote*

itemP->discount_policy() ;
//错误: itemP的类型是Quote*，它是Disc_quote的基类
//只有调用虚函数时才会发生动态解析

//14行，itemP的类型是Quote的指针，意味着对discount_policy 的搜索将从Quote开始。显然Quote不包含名为discount_policy 的成员，所以我们无法通过Quote的对象、引用或指针调用discount_policy.

```

**名字冲突与继承**

派生类可以重新定义其直接基类或间接基类中的名字，类似于内层作用域隐藏外层作用域中的同名成员

```C++
struct Base
{
Base():mem(0) { }
protected:
int mem; 
};

struct Derived : Base {
Derived(int i):mem(i) { }
//用i初始化Derived::mem，Base::mem则进行默认初始化
int get_mem() { return mem; }
//返回Derived::mem
protected:
int mem;//隐藏基类中的mem
//这是派生类自己定义的数据成员，但继承过来的数据成员是否依旧存在？？是的，访问的时候需要通过作用域运算符访问各自的
    
};

Derived d(42) ;
cout << d.get_mem() << endl;//打印42

```

**派生类的成员将隐藏同名的基类成员。**

**可以通过作用域运算符来使用隐藏的成员**

```C++
//在上面Derived的定义中修改
struct Derived : Base 
{
int get_base_mem() 
{ return Base::mem;}
};
Derived d(42) ;
cout << d.get_mem() << endl;//打印0
```

**除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。**

```C++
//调用p->men或obj.men()时，编译器的执行过程
●首先确定p(或obj)的静态类型。因为我们调用的是一个成员，所以该类型必然是类类型。
●在p(或obj)的静态类型对应的类中查找mem。如果找不到，则依次在直接基类中不断查找直至到达继承链的顶端。如果找遍了该类及其基类仍然找不到，则编译器将报错。
●一旦找到了mem,就进行常规的类型检查以确认对于当前找到的m，本次调用是否合法。
●假设调用合法，则编译器将根据调用的是否是虚函数而产生不同的代码:
//如果mem是虚函数且我们是通过引用或指针进行的调用，则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型。
//反之，如果mem不是虚函数或者我们是通过对象(而非引用或指针)进行的调用，则编译器将产生一个常规函数调用。

```

**名字查找先于类型检查**

如果派生类中的成员函数与基类中的成员函数同名，这这不能算重载，并且，即使派生类的成员函数和基类成员函数形参列表不一致，只要函数名是一样的，基类的成员函数也会被隐藏掉

```C++
struct Base
{
int memfcn() ;
};

struct Derived : Base 
{
int memfcn(int) ;//隐藏基类的memfcn
};

Derived d; 
Base b;
b.memfcn();//调用Base::memfcn
d.memfcn(10);//调用Derived::memfcn
d.memfcn();//错误:参数列表为空的memfcn被隐藏了
d.Base::memfcn();//正确:调用Base::memfcn

//如果b是一个指针，Base*b，且menfcn是虚函数
则 b->memfcn()的调用就会考虑静态类型和动态类型的问题
```

**虚函数与作用域**

基类与派生类中的虚函数必须有相同的形参列表

如果形参不同，就无法通过基类的引用或指针调用派生类的虚函数

```C++
class Base 
{
public:
virtual int fcn() ;
};

class D1 : public Base 
{
public:
int fcn(int) ;//隐藏基类的fcn,这里的fcn不是虛函数
//形参列表与Base中的fcn不一致
virtual void f2() ;
//是一个新的虚函数，在Base中不存在
//D1的fcn函数并没有覆盖Base的虚函数fcn，原因是它们的形参列表不同。
 //实际上，D1的fcn将隐藏Base的fcn。此时拥有了两个名为fcn的函数:一个是D1从Base继承而来的虚函数fcn;另一个是D1自己定义的接受一个int参数的非虚函数fcn。

   
    
class D2 : public D1 
{
public:
int fcn(int) ;//是一个非虚函数，隐藏了D1::fcn(int)
int fcn();//覆盖了Base的虚函数fcn
void f2();//覆盖了D1的虚函数f2
};
    
//通过基类调用隐藏的虚函数
Base bobj; 
D1 d1obj; 
D2 d2obj ;
Base *bp1 = &bobj, *bp2 = &d1obj, *bp3 = &d2obj ;
bp1->fcn() ;//虚调用，将在运行时调用Base::fcn
bp2->fcn() ;//虛调用，将在运行时调用Base::fcn
bp3->fcn() ;//虛调用，将在运行时调用D2::fcn
    
D1 *d1p = &d1obj; 
D2 *d2p = &d2obj;
bp2->f2() ;//错误: Base没有名为f2的成员 //这里应该会调用D1的虚函数f2啊？？
d1p->f2() ;//虚调用，将在运行时调用D1::f2()
d2p->f2() ;//虛调用，将在运行时调用D2::f2()

```

```C++
Base *p1 = &d2obj; 
D1 *p2 = &d2obj; 
D2 *p3 = &d2obj;
p1->fcn(42) ;//错误: Base中没有接受一个int的fcn
p2->fcn(42) ;//静态绑定，调用D1::fcn(int)
p3->fcn(42) ;//静态绑定，调用D2::fcn(int)

//调用非虚函数时，不会发生动态绑定，实际调用的函数版本由指针的静态类型决定，即指针是什么类型的，而不是其绑定的类型(动态类型)
```

**覆盖重载的函数**

基类中有多个同名函数的重载版本，派生类中我们只需要覆盖其中的一个版本，如果正常操作，派生类会隐藏基类中的同名函数，导致所有的重载函数都是用不了

解决方法：

在派生类的定义中，添加using 语句声明

```C++
using 基类名::重载的函数名(不加形参列表)
```

using 基类名::重载的函数名(不加形参列表)

这样就可以把该函数的所有重载实例添加到派生类作用域中，然后派生类只需要定义特有的函数就行，这时候在派生类中再定义一个同名函数，相当于多了一个重载版本，不会隐藏基类中的同名函数

## 15.7 构造函数与拷贝控制

### 15.7.1 虚析构函数

delete一个动态分配对象的指针时，指针的类型(静态类型)和指针绑定的类型(动态类型)可能不符

例如,如果我们delete一个Quote*类型的指针，则该指针有可能实际指向了一个Bulk_ quote 类型的对象。
如果这样的话，编译器就必须清楚它应该执行的是Bulk_quote 的析构函数。

**我们通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本**

```C++
class Quote {
public:
//如果我们删除的是一个指向派生类对象的基类指针，则需要虛析构函数
virtual ~Quote() = default; //动态绑定析构函数

//无论Quote使用合成的析构函数还是定义自己的析构函数，都将是虚析构函数。
//只要基类的析构函数是虚函数，就能确保当我们delete基类指针时将运行正确的析构函数版本:
Quote *itemP = new Quote;//静态类型与动态类型一致
delete itemP;//调用Quote的析构函数
itemP = new Bulk_quote;//静态类型与动态类型不一致
delete itemP ;//调用Bulk_quote的析构函数

```

**虚析构函数将阻止合成移动操作**

影响:如果一个类定义了析构函数，即它通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作(参见13.6.2 节)。

### 15.7.2 合成拷贝控制与继承

合成的拷贝控制成员也会使用基类对应的操作初始化、赋值或销毁对象的直接基类部分

例如：Bulk_ quote：Disc_ quote ：Quote

合成的Bulk_ quote默认构造函数运行Disc_ quote 的默认构造函数，后者又运行Quote的默认构造函数。

无论基类成员是合成版本还是自定义版本影响不大

**派生类的析构函数来说，它除了销毁派生类自己的成员外,还负责销毁派生类的直接基类部分;该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。**



**派生类中删除的拷贝控制与基类的关系**

●如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问，则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作。
●如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。那也就不能销毁本类对象
●编译器将不会合成一个删除掉的移动操作。当我们使用=default请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。

同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。

```C++
class B{
public:
B() ;
B(const B&) = delete;
};

class D : public B 
{
//没有声明任何构造函数
};
D d;//正确: D的合成默认构造函数使用B的默认构造函数
D d2(d) ;//错误:D的合成拷贝构造函数是被删除的
D d3(std::move(d)); //错误:隐式地使用D的被删除的拷贝构造函数

```

由于我们自定义了拷贝构造函数,所以编译器将不会为B合成一个移动构造函数(参见13.6.2节)，因此，我们既不能移动也不能拷贝B的对象。如果B的派生类希望它自己的对象能被移动和拷贝，则派生类需要自定义相应版本的构造函数。

在实际编程过程中，如果在基类中没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作。



**移动操作与继承**

因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。

因为移动派生类时也会移动其基类的部分

Quote必须显式地定义这些成员，才可以使用合成的版本的移动操作，一旦Quote定义了自己的移动操作，那么它必须同时显式地定义拷贝操作

```C++
class Quote {
public:
Quote () = default;//对成员依次进行默认初始化
Quote (const Quote&) = default;
// 对成员依次拷贝
Quote (Quote&&) = default;//对成员依次拷贝//移动拷贝构造函数
Quote& operator= (const Quote&) = default; //拷贝赋值
Quote& operator= (Quote&&) = default;//移动赋值
virtual ~Quote() = default;
};

//派生类中将自动获得合成的移动操作
```

### 15.7.3 派生类的拷贝控制成员

当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象，但销毁的时候基类部分是自动销毁的

**定义派生类的拷贝或移动构造函数**

当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分:

```c++
class Base { /* ...*/ };
class D: public Base 
{
public:
//默认情况下，基类的默认构造函数初始化对象的基类部分
//要想使用拷贝或移动构造函数，我们必须在构造函数初始值列表中
//显式地调用该构造函数
D(const D& d) : Base (d)//拷贝基类成员
 { /*D的成员的初始值*/ }
D(D&& d) : Base (std::move(d)) //移动基类成员
{/*D的成员的初始值*/}
};

//Base(d)会匹配Base的拷贝构造函数，将D的对象d传给形参，Base的拷贝构造函数负责将d的基类部分拷贝给要创建的对象

```

在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝(或移动)基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝(或移动)构造函数。



**派生类赋值运算符**

派生类的赋值运算符也必须显式地为基类部分赋值

```C++
// Base::operator= (const Base&)不会被自动调用
D &D::operator= (const D &rhs)
{
Base::operator=(rhs); 
//显示调用基类的赋值运算符，为派生类对象的基类部分赋值
//按照过去的方式为派生类的成员赋值

return *this; .
}

```

**派生类析构函数**

派生类析构函数只负责销毁由派生类自己分配的资源

```C++
class D: public Base {
public:
//Base::~Base被自动调用执行
~D() { /*该处由用户定义清除派生类成员的操作*/ }
};

```

对象销毁的顺序正好与其创建的顺序相反:

派生类析构函数首先执行，然后是基类的析构函数，以此类推。



**在构造函数和析构函数中调用虚函数**

如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。



- 小结

```C++
拷贝构造函数和拷贝移动函数：
    派生类需要显示调用基类的
构造函数和析构函数
    派生类会自动调用基类的
//待验证
```



### 15.7.4 继承的构造函数

类不能继承默认、拷贝和移动构造函数。但是可以继承自定义的版本

派生类继承基类构造函数的方式是提供一条注明了(直接)基类名的using声明语句，

```C++
class Bulk_ quote : public Disc_ quote {
public:
using Disc_quote::Disc_quote; // 继承Disc_quote 的构造函数
};

```

当using声明语句作用于构造函数时，声明语句将令编译器产生代码，对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数

```C++
//这些编译器生成的构造函数形如:
derived (parms): base (args)
//parms是构造函数的形参列表，args将派生类构造函数的形参传递给基类的构造函数。

//例如对于Bulk_quote类
Bulk_quote (const std::string& book, double price,std::size_ t qty, double disc):
Disc_quote (book, price, qty, disc) { }
//如果派生类含有自己的数据成员，这些成员将被默认初始化
```

**继承的构造函数的特点**

- 不管using声明出现在哪儿，基类的私有构造函数在派生类中还是一个私有构造函数;受保护的构造函数和公有构造函数也是同样的规则。

- 如果基类的构造函数是explicit或constexpr，则继承的构造函数也有相同的属性

- 当一个基类构造函数含有默认实参时，这些实参并不会被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。

- 例如，如果基类有一个接受两个形参的构造函数，其中第二个形参含有默认实参，则派生类将获得两个构造函数:一个构造函数接受两个形参(没有默认实参),另一个构造函数只接受一个形参，它对应于基类中最左侧的没有默认值的那个形参。

如果基类含有几个构造函数，则除了两个例外情况，大多数时候派生类会继承所有这些构造函数。

- 第一个例外是派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本。如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数将不会被继承。定义在派生类中的构造函数将替换继承而来的构造函数。
- 第二个例外是默认、拷贝和移动构造函数不会被继承。继承的构造函数不会被作为用户定义的构造函数来使用，因此，如果一个类只含有继承的构造函数，则它也将拥有一个合成的默认构造函数。

## 15.8 容器与继承

因为不允许在容器中保存不同类型的元素，所以我们不能把具有继承关系的多种类型的对象直接存放在容器当中。

```C++
vector <Quote> basket;
basket.push_back(Quote ("0-201-82470-1",50)) ;

basket.push_back(Bulk_quote ("0-201-54848-8"，50， 10，25)) ;
//正确:但是只能把对象的Quote部分拷贝给basket

cout << basket.back().net price(15) << endl;
//调用Quote定义的版本，打印750，即15*$50
//basket的元素是Quote对象，因此当我们向该vector中添加一个Bulk_quote对象时，它的派生类部分将被忽略掉

```

当派生类对象被赋值给基类对象时，其中的派生类部分将被“切掉”，因此容器和存在继承关系的类型无法兼容。



**在容器中放置(智能)指针而非对象**

当我们希望在容器中存放具有继承关系的对象时，实际上存放的通常是基类的指针，更好的选择是智能指针。 这些指针所指对象的动态类型可能是基类类型，也可能是派生类类型:

```C++
vector<shared_ptr<Quote>> basket;
basket.push_back(make_shared<Quote> ("0-201-82470-1",50)) ;
basket.push_back(make_shared<Bulk_quote> ("0-201-54848-8",50,10.25)) ;

cout << basket.back()->net_price (15) << endl;//调用Quote定义的版本;打印562.5，
//实际调用的net_price 版本依赖于指针所指对象的动态类型。


//调用push_back()时，shared_ptr<Bulk_quote>对象被转换成shared_ptr<Quote>
```

### 15.8.1 编写Basket类

见书P558，一个简单实例



## 15.9文本查询程序再探

见书P562，复杂综合实例，建议作为实践项目来看



# 16.模板与泛型编程

## 16.1 定义模板

### 16.1.1 函数模板

一个函数模板就是一个公式，可用来生成针对特定类型的函数版本

```C++
template <typename T>//template后跟模板参数列表
int compare (const T &v1，const T &v2)
{
if (v1 < v2) return -1;
if (v2 < v1) return 1;
return 0;
}
//在模板定义中，模板参数列表不能为空。
//T表示一个类型，其实际类型在编译时根据compare使用情况来确定
```



**实例化函数模板**

编译器用函数实参来推断模板实参

```C++
cout << compare (1，0) << endl; 
// 实参为int，编译器推断出模板实参为int，并绑定到模板参数T
```

编译器用推断出的模板参数来为我们**实例化**

```C++
//实例化出int compare (const int&, const int&)
cout << compare(1, 0) << endl; // T为int
//实例化出int compare (const vector<int>&， const vector<int>&)
vector<int> vec1{1, 2, 3}，vec2{4, 5, 6};
cout << compare(vec1, vec2) << endl; // T为vector<int>

//这些编译器生成的版本称为模板的实例
```

**模板参数类型**

类型参数可以用来指定返回类型或函数的类型，以及在函数体内用于变量声明或类型转换

```C++
//正确:返回类型和参数类型相同
template <typename T> 
T foo(T* p)
{
T tmp=*p;//tmp的类型将是指针p指向的类型
return tmp;
}
```

模板类型参数前必须使用关键字typename或class，这两者含义相同，可以同时使用

```C++
//错误: U之前必须加上class或typename
template <typename T,U> T calc (const T&，const U&) ;
//正确:在模板参数列表中，typename和class没有什么不同
template <typename T，class U> calc (const T&，const U&) ;

```

**非类型模板参数**

一个非类型参数表示一个值，而非一个类型，这些值必须是常量表达式，这样编译器可以在编译时实例化模板。

```C++
template<unsigned N,unsigned M>
int compare (const char (&p1) [N]，const char (&p2) [M])
{
return strcmp(p1, p2);
//当调用这个版本的compare时，编译器会使用字面常量的大小来代替N和M,从而实例化模板，编译器会在字符串字面常量末尾插入一个空字符作为终结符 
compare ("hi", "mom");
//因此调用如下版本
int compare (const char(&p1) [3]，constchar(&p2) [4])

```

- 一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或(左值)引用。
- 绑定到非类型参数的实参必须是一个常量表达式。
- 绑定到指针或引用非类型参数的实参必须具有静态的生存期？
- 不能用一个普通(非static)局部变量或动态对象作为指针或引用类型的非类型模板参数的实参。
- 指针参数也可以用nullptr或一个值为0的常量表达式来实例化。

inline和constexpr的函数模板

```C++
//正确: inline说明符跟在模板参数列表之后
template <typename T> inline T min (const T&，const T&) ;
//错误: inline说明符的位置不正确
inline template <typename T> T min (const T&，const T&) ;
```



**编写类型无关的代码**

模板程序应该尽量减少对实参类型的要求。

```C++
//期望的比较操作
if (v1 < v2) return -1;
if (v1 > v2) return 1;
return 0;
//这里要求v1和v2的类型支持<操作，如果用户调用它比较两个指针，且两个指针未指向相同的数组，则代码的行为是未定义的
//改进：
//即使用于指针也正确的compare版本;参见14.8.2节(第510页)
template <typename T> int compare (const T &vl，const T &v2)
{
if (less<T>() (v1，v2)) return -1;
if (less<T>() (v2，v1)) return 1;
return 0;
}

```

**模板编译**

当我们实例化出模板的一个特定版本，即我们使用模板时，编译器才生成代码。**模板为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义**。

**因此，模板的头文件通常既包括声明也包括定义。**

（补充：通当我们调用一个函数时，编译器只需要掌握函数的声明。

当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，普通函数和类的成员函数的定义放在源文件中。）

**模板的设计者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声明。模板的用户必须包含模板的头文件，以及用来实例化模板的任何类型的头文件。**



**大多数编译错误在实例化期间报告**

编写模板时，代码不能是针对特定类型的

```C++
//compare函数隐含假定实参类型定义了<运算符
if(v1 < v2) return -1 ;//要求类型T的对象支持<操作.
if(v2 < v1) return 1;//要求类型T的对象支持<操作.
return 0; //返回int;不依赖于T

//当编译器处理此模板时，它不能验证if语句中的条件是否合法，如果传递给compare的实参没有定义<运算符，则是错误的
Sales data datal, data2;
cout << compare (datal, data2) << endl; // 错误: Sales_data 未定义< 

```

- 第一个阶段是编译模板本身，主要检查语法错误，分号，变量名拼写
- 第二个阶段编译器遇到模板使用，检查函数调用模板的参数是否匹配
- 第三个阶段模板实例化过程，检查类型相关错误



### 16.1.2 类模板

与函数模板不同，编译器不能为类模板推断模板参数类型(函数模板在使用时会根据形参类型推断模板参数类型，而类模板需要给出模板参数类型)



**定义类模板**

```C++
template <typename T> 
class B1ob 
{
public:
typedef T value_type;
typedef typename std::vector<T>::size_type size_type;//这句话什么意思
B1ob();//构造函数
Blob(std::initializer_list<T> il) ;

size_type size() const { return data->size();}
bool empty() const { return data->empty();}//添加和删除元素
void push_ back (const T &t) {data->push_ back(t);}//移动版本，参见13.6.3节(第484页)
void push_ back(T &&t) { data->push_ back (std: :move(t));}
void pop_back() ;
T& back() ;//元素访问
T& operator[] (size_type i); 
private:
std::shared_ ptr<std: :vector<T>> data;
void check(size_ type i, const std: :string &msg) const;
};

```



**实例化类模板**

使用类模板时，需要提供**显式模板实参**

```C++
//为了用我们的Blob模板定义一个类型，必须提供元素类型:
Blob<int> ia; //空Blob<int>
Blob<int> ia2 = {0,1,2,3,4}; // 有5个元素Blob<int>

//等价于实例化下面的类//将int绑定给模板形参T
template <> class Blob<int>
{
    ...
}

//下面的定义实例化出两个不同的Blob类型
Blob<string> names; // 保存string的Blob
Blob<double> prices;// 不同的元素类型
```

一个类模板的每个实例都形成一个独立的类。类型Blob<string>与任何其他Blob类型都没有关联,也不会对任何其他Blob类型的成员有特殊访问权限。



**在模板作用域中引入模板类型**

我们通常将模板自己的参数当作被使用模板的实参

```C++
//我们模板(Blob)自己的参数就是T
//例如下面，data成员使用了两个模板
std::shared_ptr<std::vector<T>> data;
//被使用的模板即使vector和shared_ptr，将我们的模板参数T当作被使用模板的实参

//当我们实例化一个特定类型的Blob时，比如Blob<string>
//则data会变为 shared_ptr<vector<string>>
```

**类模板的成员函数**

定义在类模板内的成员函数被隐式声明为内联函数

```C++
//当在类外定义一个成员时，必须说明成员属于哪个类，
template <typename T>  //模板参数列表必须加上
ret-type Blob<T> :: member-name(parm-list)
//ret-type是返回类型，member-name是成员函数名
//parm-list是形参列表
```

**check和元素访问成员**

```C++
//在Blob的类外定义check函数成员
template <typename T>
void Blob<T>::check(size_type i, const std::string &msg) const
{
if (i >= data->size())
throw std::out_of_range(msg);
}
//下标运算符的定义
template <typename T>
T& B1ob<T>: :operator[] (size_ type i)
{
check(i, "subscript out of range") ;
return (*data) [i];
}
```

**Blob构造函数**

```C++
template <typename T>
Blob<T>::B1ob():data (std::make_shared<std::vector<T>>()) {}

template <typename T>
B1ob<T>::B1ob(std::initializer_ list<T> il) :
data(std::make_shared<std::vector<T>> (il) ) { }

```

**类模板成员函数的实例化**

默认情况下，对于一个已经实例化了的类模板，其成员只有在使用时才被实例化。

```C++
//实例化Blob<int>和接受initializer_list<int>的 构造函数
Blob<int> squares = {0,1,2,3,4,5,6,7,8,9};
//实例化Blob<int>::size() const
for (size_t i = 0; i != squares.size(); ++i)
squares[i] = i*i; //实例化Blob<int>::operator[] (size_t)

//实例化了Blob<int> 类和它的三个成员函数: operator[]、 size 和接受initializer_list<int> 的构造函数。

```

**在类代码内简化模板类名的使用**

```c++
//在类模板自己的作用域中，我们可以直接使用模板名而不提供实参
template <typename T> class BlobPtr {
public:
BlobPtr& operator++(); 
BlobPtr& operator--();
}
//前置递增和递减成员返回BlobPtr& 而不是BlobPtr<T>& 
//等价于下面声明
BlobPtr<T>& operator++();
BlobPtr<T>& operator--();

//注意：在声明的时候可以省略<T>,在类外定义时不能省略，见下
```

**在类模板外使用类模板名**

```C++
template <typename T>//成员函数的类外定义
B1obPtr<T> BlobPtr<T>::operator++ (int) 
{
BlobPtr ret = *this; // 保存当前值，
++*this;//推进一个元素;前置++检查递增是否合法
return ret;
}
//返回类型位于类的作用域之外，我们必须指出返回类型
//在函数体内，我们已经进入类的作用域，因此在定义ret时无须重复模板实参，即不需要给出<T>
//在类的作用域内，如果不提供模板实参，则编译器将假定我们使用的类型与成员实例化所用类型一致。ret的定义与如下代码等价:
BlobPtr<T> ret = *this;
```

**类模板和友元**

类是不是模板与友元是不是模板不相关

如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。

如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。



**一对一友好关系**

为了引用模板的一个特定实例，必须首先声明模板自身

```C++
//前置声明，在B1ob中声明友元所需要的
template <typename> class BlobPtr;
template <typename> class Blob; // 运算符==中的参数所需要的
template <typename T>
bool operator== (const Blob<T>&， const B1ob<T>&) ;

template <typename T> class B1ob 
{
//每个Blob实例将访问权限授予 用相同类型实例化的BlobPtr和相等运算符
friend class B1obPtr<T> ;
friend bool operator==<T> (const Blob<T>&， const Blob<T>&) ;
};
//友元的声明用Blob的模板形参作为它们自己的模板实参。因此，友好关系被限定在用相同类型实例化的Blob与BlobPtr相等运算符之间:
Blob<char> ca;//BlobPtr<char>和operator==<char>都是本对象的友元
Blob<int> ia;//BlobPtr<int>和 operator==<int>都是本对象的友元

//ca 不能访问ia ，ia也不能访问ca
```

**通用和特定的模板友好关系**

一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元:

```C++
//前置声明，在将模板的一个特定实例声明为友元时要用到
template <typename T> class Pal;

class C 
{ 
friend class Pal<C>; // 用类C实例化的Pal是C的一个友元
template <typename T> friend class Pal2;// Pal2的所有实例都是C的友元;这种情况无须前置声明
};

template <typename T> class C2 
{
// C2的每个实例将相同类型实例化的Pal声明为友元.
friend class Pal<T>; // Pal 的模板声明必须在作用城之内，如第二行
//这里Pal<T>是特定实例，所以需要前置声明，特定类型与本模板的形参类型一致
    
template <typename X> friend class Pal2;// Pal2 的所有实例都是C2的每个实例的友元，不需要前置声明
//为了让所有实例都成为友元，友元声明中必须使用与类模板本身不同的模板参数，否则变为特定实例
friend class Pal3; // Pal3 是一个非模板类，它是C2所有实例的友元 // 不需要Pal3的前置声明
};

```

**令模板自己的类型参数成为友元**

```C++
template <typename Type> class Bar 
{
friend Type; // 将访问权限授予用来实例化Bar的类型

};
//对于某个类型名Foo，Foo将成为Bar<Foo>的友元，Sales_data将成为Bar<Sales_data>的友元
```

**模板类型别名**

```C++
typedef Blob<string> StrBlob;

//模板不是类型，不能定义一个typedef引用一个模板
typedef Blob<T> TBlob; //错误
```

新标准支持模板的类型别名

```C++
template <typename T> using twin = pair<T, T> ;
twin<string> authors; //authors是一个pair<string, string>
twin<int> win_loss; // win loss是一个pair<int，int>
twin<double> area; // area是一个pair<double，double>
```

定义模板类型别名时，可以固定一个或多个模板参数

```C++
template <typename T> using partNo = pair<T, unsigned> ;
partNo<string> books; // books 是一个pair<string, unsigned>
partNo<Vehicle> cars; // cars是一个pair<Vehicle，unsigned>
partNo<Student> kids; // kids 是一个pair<Student，unsigned>
//partNo的用户只能指出pair的first成员类型，不能指定second成员的类型
//这个顺序有点类似于默认实参，只能最右边的类型是指定类型
```

**类模板的static成员**

```C++
template <typename T> class Foo 
{
public:
static std::size_t count() { return ctr; }
private:
static std::size_t ctr;
};
//对于模板Foo，其每个实例都有自己的static成员实例，
 
//实例化static成员Foo<string>::ctr和Foo<string>::count
Foo<string> fs;

//所有三个对象共享相同的Foo<int>::ctr和Foo<int>::count成员
Foo<int> fi1, fi2， fi3;

//对于某一具体类型,例如Foo<int>，该类的每个对象共享相同的静态成员
```

**将static数据成员定义为模板**

```C++
template <typename T>
size_t Foo<T>::ctr = 0; //定义并初始化ctr 
//当使用一个特定的模板实参类型实例化Foo时，将会为该类类型实例化一个独立的ctr，并将其初始化为0
```

```C++
//我们可以通过类类型对象来访问一个类模板的static成员，也可以使用作用域运算符直接访问成员。

Foo<int> fi; //实例化Foo<int>类和static数据成员ctr
ct = fi.count(); //使用Foo<int>::count
auto ct = Foo<int>::count() ; // 实例化Foo<int>::count
ct = Foo::count(); //错误:使用哪个模板实例的count?,Foo是模板
//对于某一具体类型的模板对象，才共享静态成员
//例如，Foo<int> f1,f2;  f1和f2共享静态成员
//Foo<char> f3;   f1和f3不共享静态成员，他们中的静态成员是相互独立的。

```

### 16.1.3 模板参数

```C++
//模板参数可以使用任意名字
template <typename Foo> Foo calc (const Foo& a, const Foo& b)
{
Foo tmp = a; // tmp 的类型与参数类型、返回类型一样
return tmp; 
```

**模板参数与作用域**

- 1.模板参数名的作用域在其声明之后，至模板声明或定义结束之前
- 2.模板参数会隐藏外层作用域中相同名字
- 3.模板内不能重用模板参数名

```C++
typedef double A; 
template <typename A，typename B> void f(A a, B b)
{
A tmp = a; // tmp的类型为模板参数A的类型，而非double，满足2.
double B;//错误:重声明模板参数B  违反3.
}

template <typename V, typename V> // 错误:非法重用模板参数名V，违反3.
```

**模板声明**

模板声明必须包含模板参数，模板声明时的模板参数名可以与定义时的模板参数名不同

```C++
//声明但不定义compare
template <typename T> int compare (const T&， const T&) ;

//3个calc都指向相同的函数模板
template <typename T> T calc(const T&，const T&); //声明
template <typename U> U calc(const U&，const U&); //声明

//模板的定义
template <typename Type>
Type calc(const Type& a, const Type& b) { /* ... */ }
```

**使用类的类型成员**

如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型，必须使用关键字**typename**

```C++
template <typename T>
typename T::value_type top (const T& c) 
{
return typename T::value_type();
}

```

**默认模板实参**

```C++
// compare有一个默认模板实参less<T>和一个默认函数实参F()
template <typename T，typename F = less<T>>
int compare (const T &v1, const T &v2, F f = F())
{
if (f(vl， v2)) return -1;
if (f(v2， v1)) return 1;
return 0;
}
//模板实参指出compare将使用标准库的less函数对象类，它是使用类型参数T实例化。默认函数实参指出f将是类型F的一个默认初始化的对象。
//f由可调用对象F()计算获得，


bool i = compare(0,42); //给了前两个参数，第三个参数为默认参数，使用less<int>,int是由前两个参数推断出; i为-1


Sales_data item1 (cin),item2(cin) ;
bool j = compare (item1,item2,compareIsbn) ;
//给出三个实参，compareIsbn是一个可调用对象，T为Sales_data类型，F被推断为compareIsbn类型
```



**模板默认实参与类模板**

如果一个类模板为其所有模板类型参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对

```C++
template <class T = int> class Numbers // T默认为int
{ 

};
Numbers<long double> lot; //T为long double
Numbers<> average; // 空<>表示我们希望使用默认类型，T为int

```

### 16.1.4 成员模板

普通 类包含的成员函数是模板，成员模板不能是虚函数

**普通类的成员模板**

```C++
//函数对象类，对给定指针执行delete .
class DebugDelete {
public:
DebugDelete (std::ostream &s = std::cerr): os(s) { }
//与任何函数模板相同，T的类型由编译器推断
template <typename T> void operator() (T *p) const
{ os << "deleting unique_ ptr" << std::endl; delete p; }
private:
std::ostream &Os;
};

//调用
double* p = new double;
DebugDelete d; // 可像delete表达式一样使用的对象
d(p); //调用DebugDelete: :operator() (double*)，释放p

int* ip = new int;
DebugDelete() (ip) ;//在一个临时DebugDelete对象上调用operator() (int*)


//将DebugDelete作为unique_ptr的删除器
//实例化DebugDelete::operator()<int>(int *)
unique_ptr<int, DebugDelete> p(new int, DebugDelete()) ;


//实例化DebugDelete::operator()<string> (string*)
unique_ptr<string, DebugDelete> sp(new string， DebugDelete()) ;

//unique_ptr的析构函数调用DebugDelete时会自动实例化其模板成员
//DebugDelete的成员模板实例化样例
//void DebugDelete::operator() (int *p) const { delete p; }
//void DebugDelete::operator() (string *p)const { delete p; }

```



**类模板的成员模板**

类模板的模板参数类型和成员模板的模板参数类型可以不同

```C++
template <typename T> class Blob
{
template <typename It> Blob(It b,It e) ;
};

```

成员模板是函数模板，在类模板外定义一个成员模板时，必须同时给出类模板和成员模板的模板参数列表

```C++
template <typename T> 
template <typename It> B1ob<T>::B1ob(It b，It e) :
data (std::make_shared<std::vector<T>>(b，e))
{ 
}
```

**实例化与成员模板**

我们在哪个对象上调用成员模板，编译器就根据该对象的类型来推断**类模板**参数的类型。
根据传递给**成员模板**的函数实参来推断它的模板实参

```C++
int ia[] = {0,1,2,3,4,5,6,7,8,9};
vector<long> vi = {0,1,2,3,4,5,6,7,8,9};
list<const char*> w = {"now", "is"， "the", "time"} ;

Blob<int> al (begin(ia)，end(ia)) ;//实例化Blob<int>类及其接受两个int*参数的构造函数
//a1实例化了Blob<int>::Blob(int*,int*),int*是根据begin(ia)推断出

Blob<int> a2(vi.begin()，vi.end()) ;//实例化Blob<int>类的接受两个vector<long>::iterator的构造函数


Blob<string> a3(w.begin(), w.end());//实例化Blob<string>及其接受两个list<const char*>::iterator参数的构造函数

```

### 16.1.5  控制实例化

当多个cpp文件中使用相同的模板，并在使用时提供了相同的模板类型参数，则每个文件中都会有该模板的一个实例，然而这些实例是相同的，但是相互独立，这样会造成额外的资源浪费

通过**显式实例化**来避免这种开销

```C++
//形式
extern template declaration;//实例化声明
template declaration; //实例化定义

//例如
extern template class Blob<string> ;//声明
template int compare (const int&， const int&); //实例化定义


显示实例化需要加上template关键字
模板函数：template int compare(const int&， const int&)
模板类：template class Blob<string> ;
```

当编译器遇到extern模板声明时，它不会在本文件中生成实例化代码，表明在程序其他位置有该模板的定义，可以有多个extern声明，但只能有一个定义。

**extern声明必须出现在任何使用此实例化版本的代码之前**

即先声明再使用

```C++
//这些模板类型必须在程序其他位置进行实例化（定义）
extern template class Blob<string>;
extern template int compare (const int&, const int&) ;

//注意类型参数不一样
Blob<string> sal, sa2; //实例化会出现在其他位置，因为第二行加了extern声明
// Blob<int>及其接受initializer_list的构造函数在本文件中实例化
Blob<int> al = {0,1,2,3,4,5,6,7,8,9};
Blob<int> a2(a1); // 拷贝构造函数在本文件中实例化
int i = compare(a1[0]，a2[0]); //实例化出现在其他位置


// templateBuild.cc，在这个文件实例化
//实例化文件必须为每个在其他文件中声明为extern的类型和函数提供一个的定义
template int compare (const int&， const int&) ;
template class Blob<string>; //实例化类模板的所有成员

```

对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。

**实例化定义会实例化所有成员**

一个类模板的实例化定义会实例化该模板的所有成员，包括内联的成员函数

### 16.1.6 效率与灵活性

通过在编译时绑定删除器，unique_ptr避免了间接调用删除器的运行时开销。

通过在运行时绑定删除器，shared_ ptr 使用户重载删除器更为方便。

 原理见书P600



## 16.2 模板实参推断

### 16.2.1 类型转换与模板类型参数

如果一个函数形参的类型使用了模板类型参数，那么在根据实参推断函数模板形参的时候，有特定的规则：

- 顶层const不论在形参中还是在实参中都会被忽略，但如果模板类型参数是引用类型，顶层const则变成了底层const
- 可以将一个非const对象的引用传递给const的引用形参
- 如果函数形参不是引用类型，对于数组，实参转化为指向其首元素的指针，对于函数，实参转换为一个该函数类型的指针
- 算术转换，派生类向基类的转换，用户定义的转换，都不能应用于函数模板

```C++
template <typename T> T fobj(T, T); //实参被拷贝
template <typename T> T fref (const T&， const T&); //引用

string s1 ("a value") ;
const string s2 ("another value") ;
fobj (s1, s2) ; //调用fobj (string, string); 这里顶层const被忽略
fref (s1，s2) ; //调用fref (const string&, const string&)
//将s1转换为const是允许的

int a[10],b[42];
fobj(a，b) ; //调用f(int*, int*)
fref(a, b) ; //错误:数组类型不匹配
 //形参是引用的时候，数组不会转换为指针，a和b的类型是不匹配的,为什么？？
```

将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换及数组和函数到指针的转换。其他隐式类型转换都不能用



**使用相同模板参数类型的函数形参**

一个模板类型参数用作多个函数形参

```C++
int compare(const T &v1,const T &v2);
//两个形参都是T，传递给形参的实参必须具有相同的类型    
long lng;
compare (1ng,1024); // 错误:不能实例化compare (long，int)

```

如果函数模板的形参是两种类型的，模板类型参数必须给出两个

```C++
template <typename A,typename B>
int flexibleCompare (const A& v1，const B& v2)
{
if (v1 < v2) return -1;
if (v2 < v1) return 1;
return 0;
}

long lng;
flexibleCompare(lng，1024) ; 
//正确:调用flexibleCompare(long，int)

```

**正常类型转换应用于普通函数实参**

如果函数参数类型不是模板参数，则对实参进行正常的类型转换

```C++
template <typename T> ostream &print (ostream &os, const T &obj)
{
return os << obj;
}
//第一个形参是ostream &
print (cout,42); //实例化print (ostream&, int)
ofstream f ("output") ;
print(f, 10); //使用print (ostream&,int); f隐式转换为ostream&
```

### 16.2.2 函数模板显式实参

```C++
//编译器无法推断T1，它未出现在函数参数列表中,所以不能根据实参推断出T1
template <typename T1,typename T2,typename T3>
T1 sum(T2,T3) ;
//因此每次调用sum时，必须为T1提供给一个显式模板实参
//显式模板实参在尖括号中给出，位于函数名之后，实参列表之前
// T1是显式指定的，T2和T3是从函数实参类型推断而来的
auto val3 = sum<long 1ong>(i, lng); //调用long long sum(int,1ong)，此调用显式指定T1
```

**显式模板实参按顺序匹配**

```C++
//第一个实参与第一个模板参数类型匹配，
//用户必须指定所有三个模板参数
template <typename T1,typename T2,typename T3>
T3 alternative_sum(T2， T1) ;
alternative_sum<int,double,char>(i,j)//T1是int,T2是double,T3是char
//要给出T3的类型，就必须显式指定T1和T2的类型

//错误:不能推断前几个模板参数
auto val3 = alternative_sum<long 1ong>(i, lng) ;
//long long与T1匹配，从i和lng推断T2 和T3
//而这里T3不应该通过编译器推断出

//正确:显式指定了所有三个参数
auto va12 = alternative_sum<long long, int, long>(i, lng) ;
//T1是long long，T2是int，T3是long
```



**正常类型转换应用于显式指定的实参**
对于模板类型参数已经显式指定了的函数实参，可以进行正常的类型转换

```C++
int compare(const T &v1,const T &v2);
long lng;
compare(lng,1024) ; //错误:模板参数不匹配，根绝lng和1024推断出的类型不一致
compare<long>(lng,1024) ; //正确:1024转换成long
compare<int> (lng,1024) ; //正确:lng转换成int
```



### 16.2.3 尾置返回类型与类型转换

```C++
template <typename It>
??? &fcn(It beg， It end) 
{
return *beg; // 返回序列中一个元素的引用
}
//我们不知道fcn的返回类型，因为我们不知道处理的元素序列是什么类型的

vector<int> vi = {1,2,3,4,5};
Blob<string> ca = { "hi", "bye" };
auto &i = fcn(vi.begin(), vi.end()); // fcn应该返回int& 
auto &s = fcn(ca.begin(), ca.end()); // fcn 应该返回string&

```

**通过尾置返回类型声明返回类型**

```C++
//尾置返回类型可以使用函数中局部变量
template <typename It>
auto fcn(It beg, It end) -> decltype (*beg)
{
return *beg; // 返回序列中一个元素的引用
}
//decltype推断的类型为beg表示的元素的类型的引用
```

**进行类型转换的标准库模板类**

以上函数，如果我们需要返回的是一个值，而不是引用，如何处理?

可以通过remove_reference来获得元素类型，其有一个名为type的类型成员

remove_reference<int&>，这个式子得到是int， 则type成员将是int

remove_ reference<string&>， 则type成员将是string

remove_reference<decltype (*beg)>: :type，

```C++
//上面的fcn返回类型可以修改为
template <typename It> 
auto fcn2 (It beg,It end)->typename remove_reference <decltype(*beg)>::type
{
return *beg; // 返回序列中一个元素的拷贝，而不是引用
}

//type是一个类的成员，而该类依赖于一个模板参数。因此，我们必须在返回类型的声明中使用typename来告知编译器，type 表示一个类型

```

![image-20210106141546043](./Typora_img/image-20210106141546043.png)

如果T是一个指针类型，则remove_ pointer<T>::type 是T指向的类型。如果T不是一个指针，则无须进行任何转换，type具有与T相同的类型。



### 16.2.4 函数指针和实参推断

对于函数指针，编译器使用指针的类型来推断模板实参

函数指针的类型，包括返回值和形参类型，例如 int(int,int)

```C++
template <typename T> int compare (const T&， const T&) ;
// pf1指向实例int compare (const int&， const int&)
int (*pf1) (const int&, const int&) = compare;

// func的重载版本;每个版本接受一个不同的函数指针类型.
void func(int(*) (const string&， const string&)) ;
void func(int(*) (const int&，const int&)) ;
func (compare); // 错误:使用compare的哪个实例?

//显式指定模板实参
func (compare<int>); // 传递compare (const int&, const int&) 
```



### 16.2.5 模板实参推断和引用

**从左值引用函数参数推断类型**

函数参数是普通引用时，只能传递给它一个左值，实参可以是const类型也可以不是，如果是，T推断为const类型

```C++
template <typename T> void f1 (T&); //实参必须是一个左值

f1(i); // i 是一个int;模板参数类型T是int
fl(ci); // ci是一个const int; 模板参数T是const int
f1(5); // 错误:传递给一个&参数的实参必须是一个左值

```

函数参数是const T&，可以传递任意类型的实参，const已经是函数参数的一部分，T的推断结果不会是一个const类型

```C++
template <typename T> void f2(const T&); //可以接受一个右值

//在每个调用中，f2的函数参数都被推断为const int&,但T是int
f2(i); // i是一个int;模板参数T是int
f2(ci) ; // ci是一个const int, 但模板参数T是int
f2(5); // 一个const &参数可以绑定到一个右值; T是int

```

**从右值引用函数参数推断类型**

函数参数是右值引用，T推断为右值实参的类型

```C++
template <typename T> void f3(T&&) ;
f3(42); //实参是一个int类型的右值;模板参数T是int
```

**引用折叠和右值引用参数**

如果一个模板类型参数是右值引用，如

```C++
template <typename T> void f3(T&&) ;
```

那么既可以传给他一个右值，又可以传给他一个左值

```C++
//例如：
f3(42);//42是右值，这显然正确，
int i=20;
f3(i);//i是左值，T被推断为int &, 此时形参变为T&&即 int& &&
```

引用折叠规则：

1.当把一个左值传给模板的右值形参，T类型被推断为左值引用类型，如上
2.由于不能定义引用的引用，对于上面int& &&的情况，会发生引用折叠，int& &&折叠成一个普通的左值引用类型，即int&
如：X& &、X&  &&和X&&  &都被折叠成X&
例外；只有右值引用的右值引用，才会折叠成右值引用，
如X&&  &&折叠成X&&
**因此，如果模板中有右值引用形参T&&，我们既可以传给他右值又可以传给他左值**
引用折叠只能应用于间接创建的引用的引用，如类型别名，模板形参
**编写接受右值引用参数的模板函数**
右值引用形参带来的问题：

```C++
template <typename T> void f3(T&& val)
{
T t = val; //拷贝还是绑定一个引用?
t = fcn(t); //赋值只改变t还是既改变t又改变val?
if (val == t) { /*... */ } //若T是引用类型，则一直为true .
}
```

如果传给f3一个左值，T是引用类型，if(val==t)一直为真
如果传给f3一个右值，T是普通类型，if(val==t)一直为假
所以在实际使用时，我们通常定义两个版本，一个左值版本，一个右值版本，构成重载

```C++
template <typename T> void f(T&&) ;// 绑定到非const右值
template <typename T> void f (const T&) ;//左值和const右值
```

### 16.2.6 理解std::move（缺）

缺

### 16.2.7 转发

将函数的一个或多个实参连同类型(无论是const还是左值右值) 不变的转发给其他函数

```C++
//接受一个可调用对象和另外两个参数的模板

// flip1是一个不完整的实现:顶层const和引用丢失了
template <typename F, typename T1,typename T2>
void flip1(F f，T1 tl, T2 t2)
{
f(t2，t1) ;
}
//当可调用对象(函数)f接受引用参数时，顶层const和引用会被忽略
//例如：
void f(int v1, int &v2) //注意v2是一个引用
{
cout<< v1 <<" "<< ++v2 <<endl;.
}

f(42,i); // f改变了实参i
flip1(f,j,42); //通过flip1调用f不会改变j

//flip1实例化的是
void flip1 (void(*fcn) (int，int&),int t1，int t2) ;
//j被拷贝到t1中，f中的引用参数绑定到t1，一个拷贝值，所以不会改变j
```

**定义能保持类型信息的函数参数**

通过将一个函数参数定义为一个指向模板类型参数的右值引用，我们可以保持其对应实参的所有类型信息。

使用引用参数(无论是左值还是右值)使得我们可以保持const属性，因为在引类型中的const是底层的。

```C++
template <typename F，typename T1，typename T2>
void flip2(F f, T1 &&t1, T2 &&t2)
{
f(t2，t1) ;
}
//调用flip2(f,j,42)  T1的类型推断为int& , t1被绑定到j上
```

如果一个函数参数是指向模板类型参数的右值引用(如T&&),它对应的实参的const属性和左值/右值属性将得到保持。

```C++
//flip2不能接受右值引用参数
void g(int &i，int& j)
{
cout<<i<<" "<<j<<endl;
}
flip2(g,i,42); // 错误:不能从一个左值实例化int&& 
```



**在调用中使用std::forward保持类型信息**

forward必须通过显式模板实参来调用，forward返回该显式实参类型的右值引用，即forward<T> 的返回类型是T&&

通常情况下，我们使用forward传递那些定义为模板类型参数的右值引用的函数参数。通过其返回类型上的引用折叠，forward 可以保持给定实参的左值/右值属性:

```C++
template <typename Type> intermediary (Type &&arg)
{
finalFcn(std::forward<Type> (arg)) ;
//
}
```

**当用于一个指向模板参数类型的右值引用函数参数(T&& )时，forward会保持实参类型的所有细节。**

```C++
template <typename F，typename Tl，typename T2>
void flip(F f, T1 &&t1， T2 &&t2)
{
f (std::forward<T2>(t2),std:: forward<Tl> (t1)) ;
}
//如果我们调用flip(g, i, 42), i将以int&类型传递给f，42 将以int&&类型传递给f。

```

(这块需要好好理解)

## 16.3 重载与模板

函数模板的重载：函数模板可以被另一个模板或普通非模板函数重载

调用时，如果有多个函数提供同样好的匹配

- 如果同样好的函数中只有一个是非模板函数，则选择此函数。
- 如果同样好的函数中没有非模板函数，而有多个函数模板，且其中一个模板比其他模板更特例化，则选择此模板。
- 否则，此调用有歧义。

**编写重载模板**

```C++
//打印任何我们不能处理的类型
template <typename T> string debug_rep(const T &t) {}

//注意:此函数不能用于char*; 参见16.3节(第617页)
template <typename T> string debug_rep(T *p) {}

string s("hi") ;
cout << debug_rep(s)<< endl ; //调用第一个版本
cout << debug_rep(&s) << endl ;
//两个函数都生成可行的实例:
//版本1 debug_rep(const string&), 由第一个版本的debug_rep实例化而来, T被绑定到string
//版本2 debug_rep(string*), 由第二个版本的debug_rep实例化而来,T被绑定到string。

//第二个版本精确匹配，因为第一个版本需要从普通指针向const指针隐式转换
```

**多个可行模板**

```C++
const string *sp = &s;
cout << debug_rep(sp) << endl;
//此时，上面两个模板都是可行的
//debug_rep (const string*&),由第一个版本的debug_rep实例化而来，T被绑定到string*。
//debug_rep(const string*),由第二个版本的debug_rep实例化而来，T被绑定到const string。

//此调用被解析为debug_rep(T*),更特例化的版本

//模板debug_rep(const T&)本质上可以用于任何类型，包括指针类型。此模板比debug_rep (T*)更通用，后者只能用于指针类型。没有这条规则，传递const的指针的调用永远是有歧义的。所以选择更特例化的版本debug_rep(T*)

```

**非模板和模板重载**

匹配度相同时，编译器会选择非模板版本

```C++
string debug_rep (const string &S) 
{
return " " + s +'';
}

string s("hi") ;
cout << debug_rep(s) << endl;
//有两个可用版本
//debug_rep<string> (const string&) 第一个模板，T为string
//debug_rep(const string&)，普通非模板函数。
//编译器认为一个非模板函数比一个函数模板更好。

```



**重载模板和类型转换**

C风格字符串指针和字符串字面常量。

```C++
cout << debug_rep("hi world!") << endl; // 调用debug_rep(T*)

//有三个版本可用
//debug_rep(const T&),T被绑定到char[10]。
//debug_rep(T*),T被绑定到const char。.
//debug_rep(const string&),//非模板版本，要求从const char*到string的类型转换。

//第一个和第二个是精确匹配，第三个版本需要一次类型转换，没有精确模板那么好，第二个更加特例化，所以本例调用第二个，第一个需要char*向const char*的一个隐式转换
```

```C++
//我们希望将字符指针转换为string,并调用string版本的debug_reg
string debug_rep (char *p)
{
	return debug_rep (string(p)) ;
}

string debug_rep (const char *p)
{
	return debug_rep (string(p));
}
```

**缺少声明可能导致程序行为异常**

```C++
template <typename T> string debug_rep(const T &t) ;
template <typename T> string debug_rep(T *p);
//为了使debug_rep (char*)的定义正确工作，下面的声明必须在作用域中
string debug_rep(const string &) ;//非模板函数
string debug_rep(char *p)

//如果接受一个const string&的非模板版本的声明不在作用域中, 
//返回语句将调用debug_rep(const T&)，T实例化为string的版本
return debug_rep (string(p)) ;
    
//如果忘记了声明接受string参数的普通debug_rep 版本，编译器会默默地实例化接受const T&的模板版本。
```

在定义任何函数之前，记得声明所有重载的函数版本

## 16.4 可变参数模板

可变数目的参数被称为**参数包**，包括模板参数包和函数参数包

通过省略号表示一个包，例如typename...指出接下来的参数表示0个或多个

在函数参数列表中，如果一个参数的类型是一个模板参数包，则此参数也是一个函数参数包

```C++
// Args是一个模板参数包; rest是一个函数参数包
// Args表示零个或多个模板类型参数
// rest表示零个或多个函数参数
template <typename T, typename... Args>
void foo (const T &t，const Args& ... rest) ;
//foo共有2个参数，Args是参数包类型，rest是参数包名
```

```C++
//编译器自动推断参数包中的参数数目
int i = 0; 
double d = 3.14; 
string s = "how now brown cow";
foo(i, s, 42, d); // 包中有三个参数
foo(s，42，"hi") ;//包中有两个参数
foo(d, s) //包中有一个参数
foo("hi") ;//空包

//实例化版本
void foo(const int&, const string&, const int&，const double&) ;
void foo (const string&, const int&, const char[3]&) ;
void foo (const double&, const string&) ;
void foo(const char[3]&) ;

```



**sizeof...运算符**

通过sizeof...可以知道包中有多少个元素

```C++
template<typename ... Args> void g(Args ... args) {
cout << sizeof... (Args) << endl; // 模板类型参数的数目
cout << sizeof... (args) << endl; // 函数参数的数目.

```



### 16.4.1 编写可变参数函数模板（缺）

例：见P620

### 16.4.2 包扩展（缺）

缺！

### 16.4.3 转发参数包（缺）

缺！

## 16.5 模板特例化

例如之前的函数compare无法处理特定类型(即字符指针)的情况，

```C++
//第一个版本;可以比较任意两个类型
template <typename T> int compare (const T&，const T&) ;
//第二个版本处理字符串字面常量
template<size_t N,size_t M>
int compare (const char (&) [N]，const char (&) [M]) ;


const char *p1 = "hi", *p2 = "mom" ;
compare(p1, p2); //调用第一个模板,因为无法将char*转换为数组的引用
compare("hi", "mom") ; //调用有两个非类型参数的版本
```



**为第一个版本定义一个模板特例化**

当我们特例化一个函数模板时，**必须为原模板中的每个模板参数都提供实参**。为了指出我们正在实例化一个模板， 应使用关键字template后跟一个空尖括号对 <>。空尖括号指出我们将为原模板的所有模板参数提供类型实参，相当于普通函数

```C++
// compare的特殊版本，处理字符数组的指针
template <>
int compare (const char* const &p1, const char* const &p2)
{
return strcmp(p1, p2) ;
}

template <typename T> int compare (const T&, const T&) ;//原版
//T为const char*
```

**函数重载与模板特例化**

特例化的本质是实例化一个模板，而非重载它。因此，特例化不影响函数匹配。

对于普通类和函数，丢失声明的情况(通常)很容易发现，因为编译器将不能继续处理我们的代码。

但是，如果丢失了一个特例化版本的声明，编译器通常可以用原模板生成代码。由于在丢失特例化版本时编译器通常会实例化原模板，很容易产生模板及其特例化版本声明顺序导致的错误，而这种错误又很难查找。

如果一个程序使用一个特例化版本，而同时原模板的一个实例具有相同的模板实参集合，就会产生错误。

**模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是这些模板的特例化版本。**



**类模板特例化**

例子，见P627

```C++
//必须在原模板定义所在的命名空间中特例化它
//打开std命名空间，以便特例化std::hash
namespace std {
template <>  struct hash<Sales_data>
//template<>指出我们正在定义一个特例化版本，模板参数为Sales_data
{
    
}
}
//为了让Sales data的用户能使用hash的特例化版本，我们应该在Sales_data的头文件中定义该特例化版本。

```

**类模板部分特例化**

部分特例化：类模板的特例化可以不必为所有模板参数提供实参。我们可以只指定一部分而非所有模板参数，或是参数的一部分而非全部。一个类模板的部分特例化本身是一个模板，使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参。

**我们只能部分特例化类模板，而不能部分特例化函数模板。**

```C++
//原始的、最通用的版本
template <class T> 
struct remove_reference 
{
typedef T type;
};

//部分特例化版本，将用于左值引用和右值引用
template <class T> 
struct remove_reference<T&> //左值引用
{ typedef T type; };
template <class T> 
struct remove_reference<T&&> //右值引用
{ typedef T type; };
//在类名后为特例化的模板参数指定实参
//部分特例化版本的模板参数列表是原始模板的参数列表的一个子集或者是一个特例化版本
int i;

remove_reference<decltype (42)>::type a;
// decltype(42)为int,使用原始模板

remove_reference<decltype (i)>::type b;
// decltype(i)为 int&,使用第一个(T&)部分特例化版本

remove_reference<decltype (std::move(i))>::type c;
// decitype (std::move(i))为int&&,使用第二个(即T&&)部分特例化版本

//最终a、b、c均为int类型
```

**特例化成员而不是类**

我们可以只特例化特定成员函数而不是特例化整个类模板。

```c++
//Foo是一个模板类，包含一个成员Bar,我们可以只特例化该成员:
template <typename T> 
struct Foo 
{
Foo(const T &t = T()) : mem(t) { }
void Bar() { /* ... */ }   
T mem;
};

template<> void Foo<int>::Bar() //我们正在特例化Foo<int>的成员Bar
{
    //应用于Foo<int>版本的成员
}

Foo<string> fs;//实例化Foo<string>::Foo()
fs.Bar(); //实例化并调用Foo<string>::Bar()
//这里是实例化而不是调用，是因为上面只特例化了Foo<int>::Bar，对于没有的类型，调用相当于实例化并且调用


Foo<int> fi; //实例化Foo<int>::Foo()
fi.Bar(); //使用我们特例化版本的Foo<int>::Bar()

//当我们用int实例化Foo时，Bar之外的成员像往常一样进行实例化。如果我们使用Foo<int>的成员Bar,则会使用我们定义的特例化版本。  
```
